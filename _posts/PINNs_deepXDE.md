# Table of Contents
- [ 1 - Introduction](#1)
- [ 2 - Solve Differential Equations with PINNs](#2)
  - [ 2.1 - A Simple ODE](#2.1)
  - [ 2.2 - Heat Equation](#2.2)
  - [ 2.3 - Linear System of PDEs](#2.3)
  - [ 2.4 - Helmholtz Equation](#2.4)
  - [ 2.5 - Hamilton Jacobi Equation](#2.5)
  - [ 2.6 - Kelin - Gordon Equation](#2.6)
- [ 3 - Paramter Identification without Noise](#3)
  - [ 3.1 - A Simple ODE](#3.1)
  - [ 3.2 - Heat Equation](#3.2)
  - [ 3.3 - Linear System of PDEs](#3.3)
  - [ 3.4 - Helmholtz Equation](#3.4)
  - [ 3.5 - Hamilton Jacobi Equation](#3.5)
  - [ 3.6 - Schrodinger Equation](#3.6)
- [ 4 - Paramter Identification with Noise](#4)
  - [ 4.1 - A Simple ODE](#4.1)
  - [ 4.2 - Heat Equation](#4.2)
  - [ 4.3 - Linear System of PDEs](#4.3)
  - [ 4.6 - Schrodinger Equation](#4.4)

<a name='1'></a>
## Introduction:


(Note: you can use the streamlit app: https://pinns-karkheiran.streamlit.app to solve some of the differential equations mentioned here. You can change the hyperparameters, solve parameter identification, and add noise.)

PINNs stand for Physics Informed Neural Networks, and it is used to solve system of (partial or oridnary) differential equations. The core idea is to replace the solution of a differential equation with a neural network, and then use the automatic differentiation of neural networks to define the differential operator. For example, for a 2d problem, one has the following set-up:

![PINNs-Data.jpg](data:image/jpeg;base64,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)




* Circles: Initial/Boundary conditions; Stars: equations; Squares: Data (if available)
* Suppose the equation is given by $\mathcal{N}(u) =0$,  where $\mathcal{N}(u)$ defines the equation, for example, for Burgers equation
  
$$
\mathcal{N}(u) = u_t + u u_x - \nu u_{xx} =0
$$

* Take the loss function for a given set of weights $\mathbf{w}$  to be

$$
L[\mathbf{w}]  = \mbox{Error in Equations}+ \\
\mbox{Error in Initial conditions} \\
+\mbox{Error in Boundary conditions} \\
+\mbox{Error in Fitting Data}
$$

* In terms of equations, the Loss function is defined as, for example, the total square error (or the mean square error, or mean absolute error, or ...)
  
$$
L[\mathbf{w}]  =
\frac{1}{2}
\sum_{(x_{\rm int},t_{\rm int})}
\alpha_{\rm eq}
\left\| \mathcal{N}[ u_\mathbf{w}] (x_{\rm int},t_{\rm int}) \right\|^2
\\
+
\frac{1}{2} \sum_{(x_{\rm bnd},t_{\rm bnd})} \alpha_{\rm bnd} \left\|  u_b (x_{\rm bnd},t_{\rm bnd}) -u_\mathbf{w} (x_{\rm bnd},t_{\rm bnd} )\right\|^2
\\
 +
\frac{1}{2} \sum_{(x_{\rm init},t_{\rm init})} \alpha_{\rm init}
\left\|  u_b (x_{\rm init},t_{\rm init}) -u_\mathbf{w} (x_{\rm init},t_{\rm init}) \right\|^2
\\
+
\frac{1}{2} \sum_{(x_{\rm init},t_{\rm init})} \alpha_{\rm data}
\left\|  u_{\rm data} (x_{\rm data},t_{\rm data}) -u_\mathbf{w} (x_{\rm data},t_{\rm data}) \right\|^2
$$

* Find the weights $\mathbf{w}$ minimizing $L$:  $\mathbf{w} = {\rm arg min} L[\mathbf{w}]$  
* If the loss function defined above converges to small number close to zero, one can claim that the function that is defined by the neural network is indeed the solution of the differential equaiton that satisfies the given boundary/initial conditions. This is guaranteed by the Cauchy-Kovalevskaya theorem:


  If $F$ and $f_j$ are analytic functions near 0, then the non-linear Cauchy problem
  
$$
\partial_t^k h = F(x,t,\partial_t^j\partial_x^{\alpha} h), \quad \text{where} \quad j< k, \quad \text{and} \quad |\alpha| + j \le k,
$$

  with initial conditions:
  
$$
\partial_t^j h(x,0) = f_j(x), \quad 0\le j < k,
$$

  has a unique analytic solution near 0.

### Advantaiges of PINNs: 
* PINNs do not require a mesh/grid. They learn solutions in the continuous domain, which is helpful for:
    * High-dimensional PDEs: #input nodes = # dimensions,
    * Problems with moving boundaries.
* PINNs can simultaneously handle: forward problems (solve PDEs) and inverse problems (e.g., identify unknown parameters or coefficients in PDEs from data).
* PINNs can easily include data (e.g., boundary conditions, sensor measurements, initial conditions) as part of the loss function. This makes them great for: hybrid modeling (partial physics + partial data) and data assimilation.
* PINNs use automatic differentiation (like in TensorFlow or PyTorch), which allows precise and efficient computation of derivatives needed for the PDE.
* PINNs use ML libraries and can be trained using GPUs and accelerators.
* Once trained, the model generalizes well and can predict solutions at any point in the domain.


```python
#import tensorflow.compat.v1 as tf #'2.16.2'
#tf.enable_eager_execution()
import tensorflow as tf
import deepxde as dde #'1.13.0'

from scipy.integrate import odeint, solve_ivp
import matplotlib.pyplot as plt #'3.9.2'
import numpy as np #'1.26.4'
from matplotlib import colormaps as cm
from tqdm import tqdm
import scipy #'1.15.1'

import pandas as pd
import re

from functools import partial
```

<a name='2'></a>
## Solve Differential Equations with PINNs

### A simple ODE:

Consider the equation $\frac{dy}{dx} = \cos(\omega x), \quad x\in [-\pi , \pi],$
with $y(0)=0$.

The exact solution is $y(x)=\frac{1}{\omega}\sin(\omega x)$.


*   Give the approximation to the solution using a PINN for $\omega =2$.
*   Repeat the experiment with $\omega =10$.



```python
def exact_solution(x, omega):  # Exact/reference solution
    return (1/omega)*np.sin(omega*x)
```


```python
x = np.linspace(-np.pi, np.pi, 1000)
geom = dde.geometry.TimeDomain(x[0], x[-1])

x_begin = 0; y_begin = 0
def boundary_begin(x,_):  # Since the equation is of order one, we only need one boundary/initial condition.
                          # In priciple one coulde apply the initial condion to the solutions by "Hard constrains",
                          # But for this example we decided to use it explicitly as follows:
    return dde.utils.isclose(x[0],x_begin)

def bc_func_begin(x,y,_): 
    
    return y - y_begin

bc1 = dde.icbc.OperatorBC(geom,bc_func_begin,boundary_begin)

fig, ax = plt.subplots(1, 2, figsize=(10, 5), sharey=True)



os = [2,10] #Different values for omega.
for i in [0,1]:
    omega = os[i]
    #ref_solution = partial(exact_solution, omega = omega) # Ref solution
    def ODE_deepxde(x,y):
        dy_dx = dde.grad.jacobian(y,x)
    
        return dy_dx - tf.cos(omega*x)
                
    data = dde.data.PDE(geom, ODE_deepxde,[bc1], 
                        num_domain = 1000,
                        num_boundary = 0, # Note that no boundary points is choosen. This is harmless since the ODE
                                          # is of first order, and we already applied the initial conditions
                        num_test = 200,
                        anchors = None)

    net = dde.nn.FNN([1,30,30,1], 'tanh', 'He uniform')
    
    model = dde.Model(data, net)
    model.compile('adam', lr = 0.001, metrics = [])
    losshistory, train_state = model.train(iterations = 2000, display_every = 1000)
                
    y_pred = model.predict(x[:, None])
    
 
    
    
    ax[i].plot(x, y_pred, color='r',label='PINNS Prediction', ls=':')
    ax[i].plot(x, exact_solution(x, omega = omega), lw=1, color='b', label='Exact Solution')
    ax[i].set_xlabel('x')
    ax[i].set_ylabel('y')
    ax[i].set_title('Exact and PINNS solution for omega = {}'.format(omega))            
            
    ax[i].legend()

plt.show()            
    

```

    Compiling model...
    Building feed-forward neural network...
    'build' took 1.524721 s
    
    'compile' took 7.305301 s
    
    Training model...
    
    Step      Train loss              Test loss               Test metric
    0         [4.55e+00, 0.00e+00]    [4.57e+00, 0.00e+00]    []  
    1000      [1.61e-03, 5.76e-09]    [1.59e-03, 5.76e-09]    []  
    2000      [6.16e-05, 3.57e-12]    [5.71e-05, 3.57e-12]    []  
    
    Best model at step 2000:
      train loss: 6.16e-05
      test loss: 5.71e-05
      test metric: []
    
    'train' took 17.687619 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.300893 s
    
    'compile' took 3.069659 s
    
    Training model...
    
    Step      Train loss              Test loss               Test metric
    0         [3.63e+00, 0.00e+00]    [3.66e+00, 0.00e+00]    []  
    1000      [3.70e-01, 6.38e-08]    [3.67e-01, 6.38e-08]    []  
    2000      [2.91e-01, 1.27e-08]    [2.88e-01, 1.27e-08]    []  
    
    Best model at step 2000:
      train loss: 2.91e-01
      test loss: 2.88e-01
      test metric: []
    
    'train' took 14.585632 s
    



    
![png](output_9_1.png)
    


The plots above shows a very close agreement between the exact solutions and PINNS' results, for both parameter values.

### Heat equation


Consider the heat equation $w_t - aw_{xx}=0,\qquad (x,t)\in (0,1)\times (0,1),$
with initial condition

$$ w(x,0) = x^2+1,$$

and boundary conditions

$$ w(0,t) = 2at + 1\qquad \text{and}\qquad w(1,t)= 2at +2.$$

The exact solution is

$$w(x,t)=x^2 +2at+1.$$


*   We give the approximation to the solution using a PINN for $a =1$,
*   and repeat the experiment with $a =0.01, 10$.




```python
def exact_solution(z, a):
    t = z[:,0:1]
    x = z[:,1:2]
    return x**2 + 2*a*t + 1

x = np.linspace(0,1,100)
t = np.linspace(0,1,100)

X, T = np.meshgrid(x, t)
```


```python
geom = dde.geometry.Rectangle((0,0), (1, 1))


x_begin = 0; x_end = 1
def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[1],x_begin)


def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[1],x_end)


def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],0)




As = [1,0.01,10]
preds = []
for i in [0,1,2]:
    a = As[i]
    
    ref_solution = partial(exact_solution, a = a) # Ref solution
    
    bc_bottom = dde.icbc.DirichletBC (geom, lambda z: 2*a*z[:,0:1] + 1, boundary_bottom)
    bc_top    = dde.icbc.DirichletBC (geom, lambda z: 2*a*z[:,0:1] + 2, boundary_top)
    bc_ic     = dde.icbc.DirichletBC (geom, lambda z: (z[:,1:2])**2 + 1, ic_begin)
    
    def HEAT_deepxde(z,w):
        dw_dt = dde.grad.jacobian(w,z,0,0)
        dw_dx = dde.grad.jacobian(w,z,0,1)
        d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
        return dw_dt - a * d2w_dx2
    
    
    data = dde.data.PDE(geom, HEAT_deepxde,[bc_top,bc_bottom,bc_ic],
                        solution = ref_solution,
                        num_domain = 1000,
                        num_boundary = 6,
                        num_test =50
                       )
    
    net = dde.nn.FNN([2] + [60]*4 + [1], 'tanh', 'He uniform')
    
    model = dde.Model(data, net)
    model.compile('adam', lr = 0.001, metrics = [])
    losshistory, train_state = model.train(iterations = 1000, display_every = 1000)
    
    w_pred = model.predict(np.stack((T.ravel(), X.ravel()), axis=-1)).reshape(len(t), len(x))
    
    preds.append(w_pred)
    
    

```

    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.129795 s
    
    'compile' took 1.093993 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.26e+02, 2.75e+01, 5.05e+00, 7.48e+00]    [1.11e+02, 2.75e+01, 5.05e+00, 7.48e+00]    []  
    1000      [1.77e-03, 2.28e-04, 1.72e-04, 3.46e-07]    [9.93e-04, 2.28e-04, 1.72e-04, 3.46e-07]    []  
    
    Best model at step 1000:
      train loss: 2.17e-03
      test loss: 1.39e-03
      test metric: []
    
    'train' took 18.929338 s
    
    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.096557 s
    
    'compile' took 0.605729 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [4.65e-01, 1.39e+01, 2.21e+00, 7.48e+00]    [3.93e-01, 1.39e+01, 2.21e+00, 7.48e+00]    []  
    1000      [3.52e-04, 1.42e-05, 1.02e-05, 4.52e-07]    [1.41e-04, 1.42e-05, 1.02e-05, 4.52e-07]    []  
    
    Best model at step 1000:
      train loss: 3.77e-04
      test loss: 1.66e-04
      test metric: []
    
    'train' took 20.383674 s
    
    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.104534 s
    
    'compile' took 0.855613 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.24e+04, 3.76e+02, 8.71e+01, 7.48e+00]    [1.11e+04, 3.76e+02, 8.71e+01, 7.48e+00]    []  
    1000      [8.51e-01, 5.10e+01, 7.11e+00, 2.94e-02]    [4.55e-01, 5.10e+01, 7.11e+00, 2.94e-02]    []  
    
    Best model at step 1000:
      train loss: 5.89e+01
      test loss: 5.86e+01
      test metric: []
    
    'train' took 18.778867 s
    



```python
def exact_solution(t,x, a):

    return x**2 + 2*a*t + 1

x = np.linspace(0,1,100)
t = np.linspace(0,1,100)

X, T = np.meshgrid(x, t)

fig, ax  = plt.subplots(3,3 , figsize = (21,18))

for i in range(len(As)):
    a = As[i]
    w_pred = preds [i]
    
   

    im = ax[i,0].contourf(T, X, w_pred, cmap="coolwarm", levels=100)
    ax[i,0].set_xlabel('Time')
    ax[i,0].set_ylabel('X')
    ax[i,0].set_title('PINNS solution W(T,X) for a = {}'.format(a))  
    fig.colorbar(im, ax = ax[i,0])

    im = ax[i,1].contourf(T, X, exact_solution(T,X,a), cmap="coolwarm", levels=100)
    ax[i,1].set_xlabel('Time')
    ax[i,1].set_ylabel('X')
    ax[i,1].set_title('Exact solution W(T,X) for a = {}'.format(a))
    fig.colorbar(im, ax = ax[i,1])

    im = ax[i,2].contourf(T, X, exact_solution(T,X,a) - w_pred, cmap="coolwarm", levels=100)
    ax[i,2].set_xlabel('Time')
    ax[i,2].set_ylabel('X')
    ax[i,2].set_title('Differemce of solutions for a = {}'.format(a))
    fig.colorbar(im, ax = ax[i,2])
    
plt.show()
```


    
![png](output_15_0.png)
    


Overall it seems the PINNs solution is pretty close to the actual solution. However, the value of the test/train loss for $a=10$ is 4 orders higher than the corresponding numbers for $a=1, 0.1$. This is also clear from the graphs that the final case ($a=10$) is not as precise as the others.

### A system of linear PDEs


Consider the system 

$$
\begin{array}{l}
v_t - a v_{xx} = -v ,\\
w_t - a w_{xx} =  v - 2 w.
\end{array}
$$

with initial conditions

$$
\begin{array}{l}
v(x,0) = x^2+1,\\
w(x,0) = 0,
\end{array}
$$

and boundary conditions

$$
\begin{array}{l}
v(0,t) = \left(2at+1\right)e^{-t}, \\
v(1,t) = \left(2at+2\right)e^{-t},\\
w(0,t) = \left(2at+1\right)\left(e^{-t}-e^{-2t}\right), \\
w(1,t) = \left(2at+2\right)\left(e^{-t}-e^{-2t}\right).
\end{array}
$$

The exact solution of the system is

$$
\begin{array}{l}
v(x,t)= \left(x^2 + 2at + 1\right)e^{- t},\\
w(x,t)= \left(x^2 + 2at + 1\right)\left(e^{- t}-  e^{-2t}\right).
\end{array}
$$


```python
a = 2
x_max = 1
t_max = 1

def v_sol(X, T):
    return (X**2 + 2*a*T + 1)*np.exp(-T)
def w_sol(X, T):
    return (X**2 + 2*a*T + 1)*(np.exp(-T) - np.exp(-2*T))
def sys_sol(Z):
    v = v_sol(Z[:,:1], Z[:,1:])
    w = w_sol(Z[:,:1], Z[:,1:])
    return np.stack([v.flatten(), w.flatten()], 1)

x = np.linspace(0,1,100)
t = np.linspace(0,1,100)

X, T = np.meshgrid(x, t)
```


```python
geom = dde.geometry.Rectangle((0,0), (1, 1))

x_begin = 0; x_end = 1
def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[1],x_begin)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[1],x_end)

def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],0)


bc_bottom_v = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*tf.exp(-z[:,0:1])], boundary_bottom, component = 0)
bc_bottom_w = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_bottom, component = 1)

bc_top_v    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*tf.exp(-z[:,0:1])],boundary_top, component = 0)
bc_top_w    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_top, component = 1)

bcs = [bc_top_v, bc_top_w, bc_bottom_v, bc_bottom_w]


def HEAT2_deepxde(z,y):
    
    v = y[:,0:1]
    w = y[:,1:2]
    
    dw_dt = dde.grad.jacobian(w,z,0,0)
    dw_dx = dde.grad.jacobian(w,z,0,1)
    d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
    dv_dt = dde.grad.jacobian(v,z,0,0)
    dv_dx = dde.grad.jacobian(v,z,0,1)
    d2v_dx2 = dde.grad.jacobian(dv_dx,z,0,1)
    
    return [
        dv_dt - a * d2v_dx2 + v,
        dw_dt - a * d2w_dx2 - v + 2*w
    ]

def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'
    v = q[:, 0:1]
    w = q[:, 1:2]
    t = z[:, 0:1]
    x = z[:, 1:2]
    return tf.concat([v * tf.tanh(t) + x**2+1, w * tf.tanh(t)], axis=1)


data = dde.data.PDE(geom, HEAT2_deepxde,bcs,
                        solution = sys_sol,
                        num_domain = 1000,
                        num_boundary = 6,
                        num_test=100)
    
net = dde.nn.FNN([2] + [60]*4 + [2], 'tanh', 'He uniform')
net.apply_output_transform(output_transform)

model = dde.Model(data, net)
model.compile('adam', lr = 0.001, metrics = [])
losshistory, train_state = model.train(iterations = 2000, display_every = 1000)
    
Z_pred = model.predict(np.stack((T.ravel(), X.ravel()), axis=-1)).reshape(len(t), len(x),2)



```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.137353 s
    
    'compile' took 3.434075 s
    
    Training model...
    
    Step      Train loss                                                      Test loss                                                       Test metric
    0         [2.75e+01, 2.23e+01, 9.58e-02, 3.98e+00, 6.18e-01, 5.24e-01]    [3.02e+01, 2.44e+01, 9.58e-02, 3.98e+00, 6.18e-01, 5.24e-01]    []  
    1000      [1.36e-03, 9.96e-04, 2.09e-04, 3.66e-04, 1.77e-05, 6.73e-05]    [7.25e-04, 6.33e-04, 2.09e-04, 3.66e-04, 1.77e-05, 6.73e-05]    []  
    2000      [3.38e-04, 3.75e-04, 1.79e-05, 1.08e-05, 2.21e-06, 4.39e-06]    [2.08e-04, 2.45e-04, 1.79e-05, 1.08e-05, 2.21e-06, 4.39e-06]    []  
    
    Best model at step 2000:
      train loss: 7.48e-04
      test loss: 4.88e-04
      test metric: []
    
    'train' took 62.812171 s
    



```python
plt.figure(figsize=(15, 10))
    
plt.subplot(2,3,1)
plt.contourf(T, X, Z_pred[:,:,0], cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('PINNS solution v(T,X) for a = {}'.format(a))  

plt.subplot(2,3,2)
plt.contourf(T, X, v_sol(X,T), cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('Exact solution v(T,X) for a = {}'.format(a)) 

plt.subplot(2,3,3)
plt.contourf(T, X, v_sol(X,T) - Z_pred[:,:,0], cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('Differemce of solutions for v(T,X) and a = {}'.format(a))
plt.colorbar()



plt.subplot(2,3,4)
plt.contourf(T, X, Z_pred[:,:,1], cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('PINNS solution w(T,X) for a = {}'.format(a))  

plt.subplot(2,3,5)
plt.contourf(T, X, w_sol(X,T), cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('Exact solution w(T,X) for a = {}'.format(a)) 

plt.subplot(2,3,6)
plt.contourf(T, X, w_sol(X,T) - Z_pred[:,:,1], cmap="coolwarm", levels=100)
plt.xlabel('Time')
plt.ylabel('X')
plt.title('Differemce of solutions for w(T,X) and a = {}'.format(a))
plt.colorbar()
    
plt.show()
```


    
![png](output_21_0.png)
    


Again the PINNS solution for both components (v,w) is very close to the actual solution. Specially the train/test loss is of order $10^{-4}$. We study the accuracy more precisely bellow:

### Helmholtz equation

Consider the Dirichlet problem 

$$\nabla^2 E(x,y) + \frac{\pi^2}{2}E(x,y) = 0,\qquad x,y \in \Omega =[-2, 2]^2,$$
subject to boundary conditions

$$E(-2,y)=E(2,y)=-\cos\left(\frac{\pi}{2} y\right)-\sin\left(\frac{\pi}{2} y\right),$$
$$E(x,-2)=E(x, 2)=-\cos\left(\frac{\pi}{2} x\right)-\sin\left(\frac{\pi}{2} x\right).$$

We want to find the following solution using a neural network 

$$ E^*(x,y) = \cos\frac{\pi\left(x- y\right)}{2}+ \sin\frac{\pi\left(x + y\right)}{2}.$$

There are many other solutions to the Dirichlet problem above, for example $(x,y)\mapsto \sin\left(\frac{\pi}{2} x\right)\sin\left(\frac{\pi}{2} y\right)$ is a solution. So to learn $E^*$ we need to provide the neural network with additional training points. We'll provide you with a function that generates training points from the true solution.


```python
def helm_sol(X, Y):
    return np.cos((X-Y)*np.pi/2)+np.sin((X+Y)*np.pi/2)

x_min = -2; x_max = 2
y_min = -2; y_max = 2
x = np.linspace(x_min, x_max, 100)
y = np.linspace(y_min, y_max, 100)
X, Y = np.meshgrid(x, y)

def helm_data(num_pts=10):
    X = np.random.uniform(x_min, x_max, num_pts)
    Y = np.random.uniform(y_min, y_max, num_pts)
    Z = np.stack([X, Y], 1)
    return Z, helm_sol(X, Y).reshape(num_pts, 1)

# PINNS Solutions

def exact_solution(z):
    x = z[:,0:1]
    y = z[:,1:2]
    
    E = np.cos((x-y)*np.pi/2) + np.sin((x+y)*np.pi/2)
    
    return E


geom = dde.geometry.Rectangle((x_min,y_min), (x_max,y_max))

def boundary_xmin(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_xmax(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)

def boundary_ymin(z,on_boundary):  
    return dde.utils.isclose(z[1],y_min)

def boundary_ymax(z,on_boundary):  
    return dde.utils.isclose(z[1],y_max)

bc_min_x = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,1:2]*np.pi/2) - tf.sin(z[:,1:2]*np.pi/2), boundary_xmin, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,1:2]*np.pi/2) - tf.sin(z[:,1:2]*np.pi/2), boundary_xmax, component = 0)

bc_min_y = dde.icbc.DirichletBC (geom, lambda z:  -tf.cos(z[:,0:1]*np.pi/2) - tf.sin(z[:,0:1]*np.pi/2), boundary_ymin, component = 0)
bc_max_y = dde.icbc.DirichletBC (geom, lambda z:  -tf.cos(z[:,0:1]*np.pi/2) - tf.sin(z[:,0:1]*np.pi/2), boundary_ymax, component = 0)

points, Es = helm_data(num_pts = 10)
observe = dde.icbc.PointSetBC(points, Es )

bcs = [bc_min_x, bc_max_x,bc_min_y, bc_max_y, observe]

def Helmholtz_deepxde(z,h):
    
    E = h[:, 0:1]
    
    dE_dx = dde.grad.jacobian(E,z,0,0)
    d2E_dx2 = dde.grad.jacobian(dE_dx,z,0,0)
    dE_dy = dde.grad.jacobian(E,z,0,1)
    d2E_dy2 = dde.grad.jacobian(dE_dy,z,0,1)
    
    
    return d2E_dx2 + d2E_dy2 + (2*(np.pi/2)**2) * E

data = dde.data.PDE(geom, Helmholtz_deepxde,bcs, 
                        num_domain = 1000,
                        solution = exact_solution,
                        num_boundary = 100,
                        num_test = 50,
                    anchors = points
                       )

net = dde.nn.FNN([2] + [60]*7 + [1], 'sin', 'Glorot normal')
model = dde.Model(data, net)
model.compile('adam', lr = 0.01, metrics = [])
losshistory, train_state = model.train(iterations = 1000, display_every = 1000)
    
Z_pred = model.predict(np.stack((X.ravel(), Y.ravel()), axis=-1)).reshape(len(x), len(y), 1)

```

    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.253426 s
    
    'compile' took 8.642947 s
    
    Training model...
    
    0         [1.30e+00, 1.28e+00, 1.22e+00, 8.90e-01, 8.14e-01, 1.55e+00]    [1.12e+00, 1.28e+00, 1.22e+00, 8.90e-01, 8.14e-01, 1.55e+00]    []  
    1000      [6.67e-03, 8.82e-04, 6.24e-04, 1.03e-03, 4.03e-04, 4.26e-04]    [6.34e-03, 8.82e-04, 6.24e-04, 1.03e-03, 4.03e-04, 4.26e-04]    []  
    
    Best model at step 1000:
      train loss: 1.00e-02
      test loss: 9.70e-03
      test metric: []
    
    'train' took 92.092183 s
    



```python
x = np.linspace(-2, 2, 100)
y = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x, y)
Z = helm_sol(X,Y)


fig, ax = plt.subplots(1,2 , subplot_kw={"projection": "3d"}, figsize = (20,10))

surf_PINNS = ax[0].plot_surface(X, Y, Z_pred[:,:,0], cmap="coolwarm")
fig.colorbar(surf_PINNS, shrink=0.3, aspect=5)
ax[0].set_title('PINNS Solution')

surf_EXACT = ax[1].plot_surface(X, Y, Z, cmap='coolwarm')
fig.colorbar(surf_EXACT, shrink=0.3, aspect=5)
ax[1].set_title('Exact solution')

plt.show()
```


    
![png](output_26_0.png)
    


### Hamilton-Jacobi equation

Consider the Hamilton-Jacobi equation 

$$
\begin{array}{l}\varphi_t+\sin(x)\varphi_x = 0, \;  x\in[0, 2\pi], \; t\in[0, 1], \\ \varphi(x, 0) = \sin(x), \\ \varphi(0, t) = \varphi(2\pi, t)= 0.  
\end{array}
$$

The exact solution is

$$
\varphi(x,t) = \sin\left(2\arctan\left(e^{-t}\tan\left(\frac{x}{2} \right)\right)\right)
$$


```python
# PINNS Solution:

t_max = 1; t_min = 0
x_max = 2*np.pi; x_min = 0
x = np.linspace(x_min, x_max, 100)
t = np.linspace(t_min, t_max, 100)
X, T = np.meshgrid(x, t)


geom = dde.geometry.Rectangle((x_min,t_min), (x_max,t_max))

def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)


bc_min_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_bottom, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_top,    component = 0)
bcs = [bc_min_x, bc_max_x]

def HJ_deepxde(z,y):
    
    phi = y[:, 0:1]
    x = z[:, 0:1]
    t = z[:, 1:2]
    
    dphi_dt = dde.grad.jacobian(phi,z,0,1)
    dphi_dx = dde.grad.jacobian(phi,z,0,0)
    
    
    return dphi_dt  + tf.sin(x) * dphi_dx

def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'
    phi = q[:, 0:1]
    
    x = z[:, 0:1]
    t = z[:, 1:2]
    
    return phi * tf.tanh(t) + tf.sin(x)

data = dde.data.PDE(geom, HJ_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 15,
                        num_test = 100
                       )
                       
net = dde.nn.FNN([2] + [30]*4 + [1], 'tanh', 'He normal')
net.apply_output_transform(output_transform)

model = dde.Model(data, net)
model.compile('adam', lr = 0.005, metrics = [])
losshistory, train_state = model.train(iterations = 2000, display_every = 2000)
    
Z_pred = model.predict(np.stack((X.ravel(), T.ravel()), axis=-1)).reshape(len(x), len(t), 1)
```

    Warning: 100 points required, but 104 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.174807 s
    
    'compile' took 0.596145 s
    
    Training model...
    
    Step      Train loss                        Test loss                         Test metric
    0         [3.10e-01, 8.82e-03, 7.36e-02]    [3.34e-01, 8.82e-03, 7.36e-02]    []  
    2000      [9.44e-05, 2.97e-05, 5.48e-05]    [8.15e-05, 2.97e-05, 5.48e-05]    []  
    
    Best model at step 2000:
      train loss: 1.79e-04
      test loss: 1.66e-04
      test metric: []
    
    'train' took 7.093329 s
    



```python
x = np.linspace(x_min, x_max, 100)
t = np.linspace(t_min, t_max, 100)
X, T = np.meshgrid(x, t)

plt.figure(figsize=(12,5))

plt.subplot(121)
plt.contourf(X, T, Z_pred[:,:,0], cmap="jet", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("PINNS Solution")

plt.subplot(122)
plt.contourf(X, T, np.sin(2*np.arctan(np.exp(-T)*np.tan(X/2))), cmap="jet", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("Exact solution")

plt.show()
```


    
![png](output_30_0.png)
    


It seems PINNS solution is very close to the exact solution.

### Klein-Gordon equation

#### Case 1

Let $a \in \mathbb{R}$ and $b>0$. Give an approximation to the solution of the equation 

$$\left(\partial_t^2 - a^2 \nabla^2 + b\right)\psi(x,t)=0, \quad (x,t) \in [1, 5]\times [0,T], $$

with initial conditions 

$$ \psi(x,0) = a \cos\left(\frac{\pi}{2} x \right) \quad\text{and}\quad \psi_t(x,0)=b\mu\cos\left(\frac{\pi}{2}x\right),$$

and Dirichlet boundary conditions 

$$ \psi(1,t) = \psi(5,t) = 0,$$

where 

$$\mu = \sqrt{b +\frac{a^2 \pi^2}{4}}.$$

The exact solution is 

$$\psi(x,t) = \cos\left(\frac{\pi x}{2}\right) \left(a \cos\left(\mu t \right) + b\sin\left(\mu t\right)\right).$$




```python
#PINNS Solution

a = 2
b = 3
mu = np.sqrt(b + a**2 * np.pi**2 / 4)
t_min = 0
t_max = 2
x_min = 1
x_max = 5


def exact_solution(z):
    x = z[:,0:1]
    t = z[:,1:2]
    
    psi = np.cos(x*np.pi/2)*(a*np.cos(mu*t)+b*np.sin(mu*t))
    
    return psi
    
x = np.linspace(x_min, x_max, 100)
t = np.linspace(t_min, t_max, 100)
X, T = np.meshgrid(x,t)

geom = dde.geometry.Rectangle((x_min,t_min), (x_max,t_max))

def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)

def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[1],0)


bc_min_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_bottom, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_top,    component = 0)

bc_t_min_N = dde.icbc.NeumannBC(geom,lambda z: -b*mu*tf.cos(((np.pi)/2)*z[:,0:1]),ic_begin,component=0)

bcs = [bc_min_x, bc_max_x, bc_t_min_N]

def KG_deepxde(z,y):
    
    psi = y[:, 0:1]
    
    dpsi_dt = dde.grad.jacobian(psi,z,0,1)
    d2psi_dt2 = dde.grad.jacobian(dpsi_dt,z,0,1)
    dpsi_dx = dde.grad.jacobian(psi,z,0,0)
    d2psi_dx2 = dde.grad.jacobian(dpsi_dx,z,0,0)
    
    
    return d2psi_dt2  - (a**2)* d2psi_dx2 + b*psi


def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'
    psi = q[:, 0:1]
    
    x = z[:, 0:1]
    t = z[:, 1:2]
    
    return psi * tf.tanh(t) + a*tf.cos(((np.pi)/2)*x)


data = dde.data.PDE(geom, KG_deepxde,bcs, 
                        num_domain = 1500,
                        solution = exact_solution,
                        num_boundary = 30,
                        num_test = 100
                       )
    
net = dde.nn.FNN([2] + [60]*4 + [1], 'tanh', 'Glorot uniform')
net.apply_output_transform(output_transform)

model = dde.Model(data, net)
model.compile('adam', lr = 0.005, metrics = [])
losshistory, train_state = model.train(iterations = 2000, display_every = 2000)
    
Z_pred = model.predict(np.stack((X.ravel(), T.ravel()), axis=-1)).reshape(len(x), len(t), 1)
```

    Warning: 100 points required, but 120 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.228425 s
    
    'compile' took 4.025395 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [3.25e+02, 5.63e-02, 9.56e-03, 6.24e+01]    [3.48e+02, 5.63e-02, 9.56e-03, 6.24e+01]    []  
    2000      [4.45e-01, 1.64e-03, 3.57e-02, 4.76e-02]    [4.06e-01, 1.64e-03, 3.57e-02, 4.76e-02]    []  
    
    Best model at step 2000:
      train loss: 5.30e-01
      test loss: 4.91e-01
      test metric: []
    
    'train' took 96.947859 s
    



```python
x = np.linspace(x_min, x_max, 100)
t = np.linspace(0, t_max, 100)
X, T = np.meshgrid(x, t)

plt.figure(figsize=(12,5))

plt.subplot(121)
plt.contourf(X, T, Z_pred[:,:,0], cmap="seismic", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("PINNS Solution")

plt.subplot(122)
plt.contourf(X, T, np.cos(X*np.pi/2)*(a*np.cos(mu*T)+b*np.sin(mu*T)), cmap="seismic", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("Exact solution")

plt.show()
```


    
![png](output_35_0.png)
    


So it seems the PINNS solutions if pretty close to the actual solution.

#### Case 2

Let $a \in \mathbb{R}$ and $b>0$. Give an approximation to the solution of the equation 

$$\left(\partial_t^2 - a^2 \nabla^2 + b\right)\psi(x,t)=0, \quad (x,t) \in [0, 4]\times [0,T], $$

with initial conditions 

$$ \psi(x,0) = ae^{-\frac{\pi x}{2}} \quad \text{and}\quad \psi_t(x,0)=b\mu e^{-\frac{\pi}{2}x}$$
and boundary conditions

$$\psi(0, t) = a\cos(\mu t) + b\sin(\mu t)\qquad \text{and}\qquad
 \psi(4,t) = e^{-2\pi}\left(a\cos(\mu t) + b\sin(\mu t)\right)$$

where 

$$\mu = \sqrt{b -\frac{a^2 \pi^2}{4}}.$$

The exact solution is 

$$\psi(x,t)=e^{-\frac{\pi}{2} x}\left( a\cos(\mu t)+b\sin(\mu t)\right).$$


```python
a = 1
b = 3
mu = np.sqrt(b - a**2 * np.pi**2 / 4)
t_min = 0; x_min = 0
t_max = 12
x_max = 4

x = np.linspace(x_min, x_max, 100)
t = np.linspace(t_min, t_max, 100)
X, T = np.meshgrid(x,t)


#PINNS Solution

def exact_solution(z):
    x = z[:,0:1]
    t = z[:,1:2]
    
    psi = np.exp(-(np.pi/2)*x)*(a*np.cos(mu*t)+b*np.sin(mu*t))
    
    return psi
    

geom = dde.geometry.Rectangle((x_min,t_min), (x_max,t_max))

def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)

def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[1],0)


bc_min_x = dde.icbc.DirichletBC (geom, lambda z: a*tf.cos(mu*z[:,1:2])+b*tf.sin(mu*z[:,1:2]), boundary_bottom, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: tf.exp(-2*np.pi)*(a*tf.cos(mu*z[:,1:2])+b*tf.sin(mu*z[:,1:2])), boundary_top,    component = 0)

bc_t_min_N = dde.icbc.NeumannBC(geom,lambda z: -b*mu*tf.exp(-(np.pi/2)*z[:,0:1]),ic_begin,component=0)

bcs = [bc_min_x, bc_max_x, bc_t_min_N]

def KG_deepxde(z,y):
    
    psi = y[:, 0:1]
    
    dpsi_dt = dde.grad.jacobian(psi,z,0,1)
    d2psi_dt2 = dde.grad.jacobian(dpsi_dt,z,0,1)
    dpsi_dx = dde.grad.jacobian(psi,z,0,0)
    d2psi_dx2 = dde.grad.jacobian(dpsi_dx,z,0,0)
    
    
    return d2psi_dt2  - (a**2)* d2psi_dx2 + b*psi


def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'
    psi = q[:, 0:1]
    
    x = z[:, 0:1]
    t = z[:, 1:2]
    
    return psi * tf.tanh(t) + a*tf.exp(-(np.pi/2)*x)


data = dde.data.PDE(geom, KG_deepxde,bcs, 
                        num_domain = 1500,
                        solution = exact_solution,
                        num_boundary = 30,
                        num_test = 100
                       )
    
net = dde.nn.FNN([2] + [60]*4 + [1], 'tanh', 'Glorot uniform')
net.apply_output_transform(output_transform)

model = dde.Model(data, net)
model.compile('adam', lr = 0.005, metrics = [])
losshistory, train_state = model.train(iterations = 2000, display_every = 2000)
    
Z_pred = model.predict(np.stack((X.ravel(), T.ravel()), axis=-1)).reshape(len(x), len(t), 1)

```

    Warning: 100 points required, but 108 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 1.233928 s
    
    'compile' took 25.927620 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [3.68e-01, 5.44e+00, 1.38e-01, 7.73e-01]    [3.46e-01, 5.44e+00, 1.38e-01, 7.73e-01]    []  
    2000      [9.21e-04, 3.83e-04, 6.15e-06, 1.70e-06]    [9.07e-04, 3.83e-04, 6.15e-06, 1.70e-06]    []  
    
    Best model at step 2000:
      train loss: 1.31e-03
      test loss: 1.30e-03
      test metric: []
    
    'train' took 119.767562 s
    



```python
x = np.linspace(x_min, x_max, 100)
t = np.linspace(0, t_max, 100)
X, T = np.meshgrid(x, t)

plt.figure(figsize=(12,5))

plt.subplot(121)
plt.contourf(X, T, Z_pred[:,:,0], cmap="seismic", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("PINNS Solution")

plt.subplot(122)
plt.contourf(X, T, np.exp(-(np.pi/2)*X)*(a*np.cos(mu*T)+b*np.sin(mu*T)), cmap="seismic", levels=100)
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.title("Exact solution")

plt.show()
```


    
![png](output_39_0.png)
    


Again PINNS returns a very good approxiamte in this case.

## Parameter Identification without Noise

### A simple ODE

$$\frac{dy}{dx} =\cos(\omega x), \quad x\in [-\pi , \pi],$$
with $y(0)=0$.

The exact solution is $y(x)=\frac{1}{\omega}\sin(\omega x)$.

* Use the following function to generate data points and learn the paramater $\omega^*=2$.


```python
omega_star = 2.
x_max = 2*np.pi

def gen_data(num_pts=10, omega_star = omega_star):
    x = np.random.uniform(0, x_max, [num_pts, 1])
    return x, np.sin(omega_star*x)/omega_star

```


```python
x = np.linspace(-np.pi, np.pi, 1000)
geom = dde.geometry.TimeDomain(x[0], x[-1])

x_begin = 0; y_begin = 0
def boundary_begin(x,_):  
    return dde.utils.isclose(x[0],x_begin)

def bc_func_begin(x,y,_): 
    
    return y - y_begin

bc1 = dde.icbc.OperatorBC(geom,bc_func_begin,boundary_begin)
points, ys = gen_data(omega_star = omega_star)
observe = dde.icbc.PointSetBC(points, ys )
bcs = [bc1, observe]

def Simple_ODE(omega_in, iter_in):

    omega = tf.Variable(omega_in)
    def ODE_deepxde(x,y):
        dy_dx = dde.grad.jacobian(y,x)
    
        return dy_dx - tf.cos(omega*x)
                
    data = dde.data.PDE(geom, ODE_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 2, 
                        num_test = 100,
                   anchors = points)

    net = dde.nn.FNN([1] + [15]*6 + [1], 'sin', 'Glorot uniform')
    model = dde.Model(data, net)
    
    parameters = dde.callbacks.VariableValue([omega], period=200, filename = 'params.csv')
    
    
    model.compile('adam', lr = 0.03, metrics = [])
    losshistory, train_state = model.train(iterations = iter_in, 
                                           callbacks=[parameters],
                                          verbose = 0)
    
```


```python
omega_ins = [5., 1.]
iter_in = 5000
omega_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
for k in range(len(omega_ins)):
    omega_in = omega_ins[k]
    
    params = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    trials = 3
    for j in range(trials):
        Simple_ODE(omega_in = omega_in, iter_in = iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 0:'par_value' }, inplace = True)        
        params['par_value'+str(j)] = params0['par_value'].apply(lambda x: float(re.findall('\[\d.+',x)[0][1:-1]))

    omega_all['mean'+str(k)] = params[['par_value'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    omega_all['std' +str(k)] = params[['par_value'+str(t) for t in range(trials)]].apply(np.std, axis = 1)


```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.189994 s
    
    'compile' took 58.020289 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.309706 s
    
    'compile' took 4.925166 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.826801 s
    
    'compile' took 6.439524 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.150005 s
    
    'compile' took 3.767120 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.157440 s
    
    'compile' took 3.828671 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.283048 s
    
    'compile' took 6.108091 s
    



```python
plt.figure(figsize = (5,5))
for k in range(2):
    plt.errorbar(x = omega_all['Epoch'], y = omega_all['mean'+str(k)], yerr = omega_all['std'+str(k)],label = f'Initital Value = {omega_ins[k]}')
    plt.scatter(x = omega_all['Epoch'], y = omega_all['mean'+str(k)])
plt.hlines(2., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted values VS epochs')
plt.legend()
plt.show()
```


    
![png](output_47_0.png)
    


### Heat equation

$$w_t - \lambda w_{xx}=0,\qquad (x,t)\in (0,1)\times (0,1),$$

with initial condition

$$ w(x,0) = x^2+1,$$
and boundary conditions

$$ w(0,t) = 2\lambda t + 1\qquad \text{and}\qquad w(1,t)= 2\lambda t +2.$$

The exact solution is

$$w(x,t)=x^2 +2\lambda t+1.$$

* Use the following function to generate data points and learn the paramater $\lambda^*=0.5$.


```python

def gen_data(num_pts=10, lmbda_star = 0.5):
    z = np.random.uniform(0, 1, [num_pts, 2])
    return z, z[:,0:1]**2 + 2*lmbda_star*z[:,1:2] + 1
```


```python


geom = dde.geometry.Rectangle((0,0), (1, 1))
x_begin = 0; x_end = 1
def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[1],x_begin)


def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[1],x_end)


def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],0)

lmbda_star = 0.5
bc_bottom = dde.icbc.DirichletBC (geom, lambda z: 2*lmbda_star*z[:,0:1] + 1, boundary_bottom)
bc_top    = dde.icbc.DirichletBC (geom, lambda z: 2*lmbda_star*z[:,0:1] + 2, boundary_top)
bc_ic     = dde.icbc.DirichletBC (geom, lambda z: (z[:,1:2])**2 + 1, ic_begin)
    
points, ws = gen_data(lmbda_star = lmbda_star)
observe   = dde.icbc.PointSetBC(points, ws)
bcs = [bc_bottom,bc_top,bc_ic,observe]


def HEAT_PDE(l_in , iters_in):
    
    Lambda = tf.Variable(l_in)
    
    

    def HEAT_deepxde(z,w):
        dw_dt = dde.grad.jacobian(w,z,0,0)
        dw_dx = dde.grad.jacobian(w,z,0,1)
        d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
        return dw_dt - Lambda * d2w_dx2
    
    
    data = dde.data.PDE(geom, HEAT_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 50)
    
    net = dde.nn.FNN([2] + [30]*5 + [1], 'sin', 'Glorot normal')
    parameters = dde.callbacks.VariableValue([Lambda], period=200, filename = 'params.csv')

    model = dde.Model(data, net)
    model.compile('adam', lr = 0.1, metrics = [])
    losshistory, train_state = model.train(iterations = iters_in, 
                                           callbacks=[parameters],
                                          verbose = 0)


```


```python
lambda_ins = [1., 0.1]
iter_in = 4000
lambda_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
for k in range(len(lambda_ins)):
    l_in = lambda_ins[k]
    
    params = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    trials = 3
    for j in range(trials):
        HEAT_PDE(l_in , iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 0:'par_value' }, inplace = True)        
        params['par_value'+str(j)] = params0['par_value'].apply(lambda x: float(re.findall('\[.+',x)[0][1:-1]))

    lambda_all['mean'+str(k)] = params[['par_value'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    lambda_all['std' +str(k)] = params[['par_value'+str(t) for t in range(trials)]].apply(np.std, axis = 1)


```

    Compiling model...
    Building feed-forward neural network...
    'build' took 2.098721 s
    
    'compile' took 23.328576 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 2.314242 s
    
    'compile' took 16.947184 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 1.294780 s
    
    'compile' took 15.030651 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 1.500192 s
    
    'compile' took 11.203692 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.556046 s
    
    'compile' took 9.557672 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 1.318314 s
    
    'compile' took 122.568636 s
    



```python
plt.figure(figsize = (5,5))
for k in range(len(lambda_ins)):
    plt.errorbar(x = lambda_all['Epoch'], y = lambda_all['mean'+str(k)], yerr = lambda_all['std'+str(k)],label = f'Initital Value = {lambda_ins[k]}')
    plt.scatter(x = lambda_all['Epoch'], y = lambda_all['mean'+str(k)])
plt.hlines(0.5, xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted values VS epochs')
plt.legend()
plt.show()
```


    
![png](output_53_0.png)
    


### A system of linear PDEs


Consider the system 

$$
\begin{cases}
v_t - \frac{1}{2} v_{xx} = \alpha v +\beta w,\\
w_t - \frac{1}{2} w_{xx} = \gamma v + \delta w.
\end{cases}
$$

with initial conditions

$$
\begin{array}{l}
v(x,0) = x^2+1,\\
w(x,0) = 0,
\end{array}
$$

and boundary conditions

$$
\begin{array}{l}
v(0,t) = \left(t+1\right)e^{-t}, \\
v(1,t) = \left(t+2\right)e^{-t},\\
w(0,t) = \left(t+1\right)\left(e^{-t}-e^{-2t}\right), \\
w(1,t) = \left(t+2\right)\left(e^{-t}-e^{-2t}\right).
\end{array}
$$

The exact solution of the system is

$$
\begin{array}{l}
v(x,t)= \left(x^2 + t + 1\right)e^{- t},\\
w(x,t)= \left(x^2 + t + 1\right)\left(e^{- t}-  e^{-2t}\right).
\end{array}
$$

The true parameters are

$$
\alpha^* =  -1, \quad \beta^* = 0, \quad \gamma^* = 1, \quad \delta^* =-2,
$$

* Use data generated from the exact solution to leanr the parameters $\alpha, \beta, \gamma$ and $ \delta$.


```python
x_max = 1
t_max = 1

def v_sol(X, T):
    return (X**2 + T + 1)*np.exp(-T)
def w_sol(X, T):
    return (X**2 + T + 1)*(np.exp(-T) - np.exp(-2*T))
def gen_data(num_pts=10):
    Z = np.random.uniform(0, 1, [num_pts, 2])
    v = v_sol(Z[:,:1], Z[:,1:])
    w = w_sol(Z[:,:1], Z[:,1:])
    return Z, np.stack([v.flatten(), w.flatten()], 1)
```


```python

geom = dde.geometry.Rectangle((0,0), (1, 1))

x_begin = 0; x_end = 1
def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[1],x_begin)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[1],x_end)

def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],0)


a = 0.5

bc_bottom_v = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*tf.exp(-z[:,0:1])], boundary_bottom, component = 0)
bc_bottom_w = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_bottom, component = 1)

bc_top_v    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*tf.exp(-z[:,0:1])],boundary_top, component = 0)
bc_top_w    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_top, component = 1)

points, Zs = gen_data(500)
obs_v = dde.icbc.PointSetBC(points, Zs[:,0:1],component = 0)
obs_w = dde.icbc.PointSetBC(points, Zs[:,1:2],component = 1)

bcs = [bc_top_v, bc_top_w, bc_bottom_v, bc_bottom_w, obs_v, obs_w]

def HEAT2_PDE(alpha = tf.Variable(-1.),
              beta = tf.Variable(0.), 
              gamma = tf.Variable(1.), 
              delta = tf.Variable(-2.), iters_in = 4000):

    def HEAT2_deepxde(z,y):
    
        v = y[:,0:1]
        w = y[:,1:2]
    
        dw_dt = dde.grad.jacobian(w,z,0,0)
        dw_dx = dde.grad.jacobian(w,z,0,1)
        d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
        dv_dt = dde.grad.jacobian(v,z,0,0)
        dv_dx = dde.grad.jacobian(v,z,0,1)
        d2v_dx2 = dde.grad.jacobian(dv_dx,z,0,1)
    
        return [
            dv_dt - a * d2v_dx2 - alpha*v - beta*w,
            dw_dt - a * d2w_dx2 - gamma*v - delta*w
            ]

    def output_transform(z, q): # With this transformation the initial conditions are automatically satisfied.
        v = q[:, 0:1]
        w = q[:, 1:2]
        t = z[:, 0:1]
        x = z[:, 1:2]
        return tf.concat([v * tf.tanh(t) + x**2+1, w * tf.tanh(t)], axis=1)


    data = dde.data.PDE(geom, HEAT2_deepxde,bcs, 
                        num_domain = 1500,
                        num_boundary = 60,
                   anchors = points)
    
    net = dde.nn.FNN([2] + [30]*3 + [2], 'sin', 'Glorot uniform')
    net.apply_output_transform(output_transform)
    parameters = dde.callbacks.VariableValue([alpha,beta,gamma,delta], period = 200, filename = 'params.csv')


    model = dde.Model(data, net)
    model.compile('adam', lr = 0.05, metrics = [])
    losshistory, train_state = model.train(iterations = iters_in, 
                                           callbacks = [parameters],
                                          verbose = 0)
    
  
```


```python
pars = [[-2.,-1.,0.,-3.],
       [-1.5,-0.5,0.5,-2.5],
       [-0.5,0.5,2.,-1.5] ]

iter_in = 4000
alpha_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
beta_all  = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
gamma_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
delta_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
for k in range(len(pars)):
    
    alpha_df = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    beta_df  = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    gamma_df = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    delta_df = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    trials = 3
    for j in range(trials):
        HEAT2_PDE(alpha = tf.Variable(pars[k][0]),
              beta = tf.Variable(pars[k][1]), 
              gamma = tf.Variable(pars[k][2]), 
              delta = tf.Variable(pars[k][3]), iters_in = iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 
                                  0:'par_value_a', 
                                  1:'par_value_b', 
                                  2:'par_value_g', 
                                  3:'par_value_d'}, inplace = True)        
        alpha_df['par_value_a'+str(j)] = params0['par_value_a'].apply(lambda x: float(re.findall('\[.+',x)[0][1:]))
        beta_df['par_value_b'+str(j)]  = params0['par_value_b'].apply(lambda x: float(x))
        gamma_df['par_value_g'+str(j)] = params0['par_value_g'].apply(lambda x: float(x))
        delta_df['par_value_d'+str(j)] = params0['par_value_d'].apply(lambda x: float(re.findall('[^\s].+\]',x)[0][0:-1]))

    
    alpha_all['mean'+str(k)] = alpha_df[['par_value_a'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    alpha_all['std' +str(k)] = alpha_df[['par_value_a'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

    beta_all['mean'+str(k)]  = beta_df[['par_value_b'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    beta_all['std' +str(k)]  = beta_df[['par_value_b'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

    gamma_all['mean'+str(k)] = gamma_df[['par_value_g'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    gamma_all['std' +str(k)] = gamma_df[['par_value_g'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

    delta_all['mean'+str(k)] = delta_df[['par_value_d'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    delta_all['std' +str(k)] = delta_df[['par_value_d'+str(t) for t in range(trials)]].apply(np.std, axis = 1)


```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.413489 s
    
    'compile' took 25.298364 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.317912 s
    
    'compile' took 5.433753 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.105970 s
    
    'compile' took 4.680427 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.146261 s
    
    'compile' took 5.963712 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.130295 s
    
    'compile' took 4.866224 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.140906 s
    
    'compile' took 5.535195 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.417668 s
    
    'compile' took 7.540054 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.167322 s
    
    'compile' took 10.847989 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.244302 s
    
    'compile' took 35.534716 s
    



```python
plt.figure(figsize = (20,20))

plt.subplot(221)
for k in range(len(pars)):
    plt.errorbar(x = alpha_all['Epoch'], y = alpha_all['mean'+str(k)], yerr = alpha_all['std'+str(k)],label = f'Initital Value = {pars[k][0]}')
    plt.scatter( x = alpha_all['Epoch'], y = alpha_all['mean'+str(k)])
plt.hlines(-1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted alpha values VS epochs')
plt.legend()

plt.subplot(222)
for k in range(len(pars)):
    plt.errorbar(x = beta_all['Epoch'], y = beta_all['mean'+str(k)], yerr = beta_all['std'+str(k)],label = f'Initital Value = {pars[k][1]}')
    plt.scatter( x = beta_all['Epoch'], y = beta_all['mean'+str(k)])
plt.hlines(-1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted beta values VS epochs')
plt.legend()

plt.subplot(223)
for k in range(len(pars)):
    plt.errorbar(x = gamma_all['Epoch'], y = gamma_all['mean'+str(k)], yerr = gamma_all['std'+str(k)],label = f'Initital Value = {pars[k][2]}')
    plt.scatter( x = gamma_all['Epoch'], y = gamma_all['mean'+str(k)])
plt.hlines(-1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted gamma values VS epochs')
plt.legend()

plt.subplot(224)
for k in range(len(pars)):
    plt.errorbar(x = delta_all['Epoch'], y = delta_all['mean'+str(k)], yerr = delta_all['std'+str(k)],label = f'Initital Value = {pars[k][3]}')
    plt.scatter( x = delta_all['Epoch'], y = delta_all['mean'+str(k)])
plt.hlines(-1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted delta values VS epochs')
plt.legend()

plt.show()
```


    
![png](output_59_0.png)
    


### Helmholtz equation

We want to determine $\lambda$ for which 

$$\nabla^2 E(x,y) + \lambda E(x,y) = 0,\qquad x,y \in \Omega =[-2, 2]^2,$$

subject to boundary conditions

$$E(-2,y)=E(2,y)=-\cos\left(\frac{\pi}{2} y\right)-\sin\left(\frac{\pi}{2} y\right),$$
$$E(x,-2)=E(x, 2)=-\cos\left(\frac{\pi}{2} x\right)-\sin\left(\frac{\pi}{2} x\right).$$

We draw data points from the particular solution 

$$ E^*(x,y) = \cos\frac{\pi\left(x- y\right)}{2}+ \sin\frac{\pi\left(x + y\right)}{2}.$$

The true value is $\lambda^* =\frac{\pi^2}{2}$.


* Learn $\lambda$ from data using the function.


```python
def helm_sol(X, Y):
    return np.cos((X-Y)*np.pi/2)+np.sin((X+Y)*np.pi/2)

def helm_data(num_pts=10):
    X = np.random.uniform(-2, 2, num_pts)
    Y = np.random.uniform(-2, 2, num_pts)
    Z = np.stack([X, Y], 1)
    return Z, helm_sol(X, Y).reshape(num_pts, 1)


x_min = -2; x_max = 2
y_min = -2; y_max = 2
x = np.linspace(x_min, x_max, 100)
y = np.linspace(y_min, y_max, 100)
X, Y = np.meshgrid(x, y)
```


```python
geom = dde.geometry.Rectangle((x_min,y_min), (x_max,y_max))

def boundary_xmin(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_xmax(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)

def boundary_ymin(z,on_boundary):  
    return dde.utils.isclose(z[1],y_min)

def boundary_ymax(z,on_boundary):  
    return dde.utils.isclose(z[1],y_max)

bc_min_x = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,1:2]*np.pi/2) - tf.sin(z[:,1:2]*np.pi/2), boundary_xmin, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,1:2]*np.pi/2) - tf.sin(z[:,1:2]*np.pi/2), boundary_xmax, component = 0)

bc_min_y = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,0:1]*np.pi/2) - tf.sin(z[:,0:1]*np.pi/2), boundary_ymin, component = 0)
bc_max_y = dde.icbc.DirichletBC (geom, lambda z: -tf.cos(z[:,0:1]*np.pi/2) - tf.sin(z[:,0:1]*np.pi/2), boundary_ymax, component = 0)

points, Es = helm_data(num_pts = 10)
observe = dde.icbc.PointSetBC(points, Es )

bcs = [bc_min_x, bc_max_x,bc_min_y, bc_max_y, observe]
def Helmholtz_PDE(l_in, iter_in):
    iters = iter_in
    Lambda = tf.Variable(l_in)
    def Helmholtz_deepxde(z,h):
    
        E = h[:, 0:1]
    
        dE_dx = dde.grad.jacobian(E,z,0,0)
        d2E_dx2 = dde.grad.jacobian(dE_dx,z,0,0)
        dE_dy = dde.grad.jacobian(E,z,0,1)
        d2E_dy2 = dde.grad.jacobian(dE_dy,z,0,1)
    
    
        return d2E_dx2 + d2E_dy2 + Lambda * E

    data = dde.data.PDE(geom, Helmholtz_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 100,
                        num_test = 50
                       )

    net = dde.nn.FNN([2] + [60]*5 + [1], 'sin', 'Glorot normal')
    parameters = dde.callbacks.VariableValue([Lambda], period = 200, filename = 'params.csv' )
    
    model = dde.Model(data, net)
    model.compile('adam', lr = 0.01, metrics = [])
    losshistory, train_state = model.train(iterations = iters, 
                                           display_every = 1000,
                                           verbose = 0,
                                           callbacks = [parameters])
    
    Z_pred = model.predict(np.stack((X.ravel(), Y.ravel()), axis=-1)).reshape(len(x), len(y), 1)

    
    
    

```


```python
l_ins = [7.]
iter_in = 4000
lambda_all = pd.DataFrame({'Epoch':[200*i for i in range(21)]})
for k in range(len(l_ins)):
    l_in = l_ins[k]
    
    params = pd.DataFrame({'Epoch':[200*i for i in range(21)]})
    for j in range(3):
        Helmholtz_PDE(l_in = l_in, iter_in = iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 0:'par_value' }, inplace = True)        
        params['par_value'+str(j)] = params0['par_value'].apply(lambda x: float(re.findall('\[\d.+',x)[0][1:-1]))

    lambda_all['mean'+str(k)] = params[['par_value0','par_value1','par_value2']].apply(np.mean, axis = 1)
    lambda_all['std'+str(k)] =  params[['par_value0','par_value1','par_value2']].apply(np.std, axis = 1)





```

    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 4.601998 s
    
    'compile' took 44.068607 s
    
    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 4.493658 s
    
    'compile' took 361.937912 s
    
    Warning: 50 points required, but 64 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 4.010431 s
    
    'compile' took 36.095186 s
    



```python
plt.figure(figsize = (10,10))
for k in range(1):
    lambda_all.plot.scatter(x = 'Epoch', y = 'mean'+str(k), yerr = 'std'+str(k), rot = 'vertical', ylabel = 'Lambda', label = f'Initital Value = {l_ins[k]}')
plt.hlines((np.pi**2)/2, xmin = 0, xmax = 4000, color = 'red', label = 'True Value')
plt.title('Predicted values VS epochs')
plt.legend()
plt.show()
```


    <Figure size 1000x1000 with 0 Axes>



    
![png](output_65_1.png)
    


### Hamilton-Jacobi equation

The goal is to see whether it is possible to learn $a$ and $b$ from data in the following equation 

$$
\begin{array}{l}a \varphi_t+b\sin(x)\varphi_x = 0, \;  x\in[-\pi, \pi], \; t\in[0, 1], \\ \varphi(x, 0) = \sin(x), \\ \varphi(-\pi, t) = \varphi(\pi, t)= 0.  \end{array} 
$$

The true parameters we want to learn are $a^*=b^*=1$, for which the exact solution is

$$
\varphi(x,t) = \sin\left(2\arctan\left(e^{-t}\tan\left(\frac{x}{2} \right)\right)\right)
$$

1. Try learning $a$ and $b$ from data using the function above.
2. Can you explain the issue?


```python
def gen_data(num_pts=500):
    X = np.random.uniform(-np.pi, np.pi, num_pts)
    T = np.random.uniform(0, 1, num_pts)
    return np.stack([X,T], 1), np.sin(2*np.arctan(np.exp(-T)*np.tan(X/2))).reshape(num_pts, 1)

def phi_exact(z):
    t = z[:,1:2]
    x = z[:,0:1]
    
    return np.sin(2*np.arctan(np.exp(-t)*np.tan(x/2)))
```


```python
# PINNS Solution:

t_max = 1; t_min = 0
x_max = np.pi; x_min = -np.pi
x = np.linspace(x_min, x_max, 100)
t = np.linspace(t_min, t_max, 100)
X, T = np.meshgrid(x, t)

geom = dde.geometry.Rectangle((x_min,t_min), (x_max,t_max))

def boundary_bottom(z,on_boundary):  
    return dde.utils.isclose(z[0],x_min)

def boundary_top(z,on_boundary):  
    return dde.utils.isclose(z[0],x_max)


bc_min_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_bottom, component = 0)
bc_max_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_top,    component = 0)

points, phis = gen_data()
obs_phi = dde.icbc.PointSetBC(points, phis,component = 0)

bcs = [bc_min_x, bc_max_x, obs_phi]

def HJ_PDE(a_in, b_in, iter_in):
    
    iters = iter_in
    a = tf.Variable(a_in)
    b = tf.Variable(b_in)
    
    def HJ_deepxde(z,y):
    
        phi = y[:, 0:1]
        x = z[:, 0:1]
        t = z[:, 1:2]
    
        dphi_dt = dde.grad.jacobian(phi,z,0,1)
        dphi_dx = dde.grad.jacobian(phi,z,0,0)
    
    
        return a*dphi_dt  + b*tf.sin(x) * dphi_dx

    def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'
        phi = q[:, 0:1]
    
        x = z[:, 0:1]
        t = z[:, 1:2]
    
        return phi * tf.tanh(t) + tf.sin(x)

    data = dde.data.PDE(geom, HJ_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 100,
                        num_test = 50
                       )
                       
    net = dde.nn.FNN([2] + [40]*3 + [1], 'sin', 'Glorot normal')
    net.apply_output_transform(output_transform)
    parameters = dde.callbacks.VariableValue([a, b], period = 200, filename = 'params.csv')

    model = dde.Model(data, net)
    model.compile('adam', lr = 0.005, metrics = [])
    
    
    losshistory, train_state = model.train(iterations = iters, 
                                           callbacks = [parameters],
                                          verbose = 0)
    
    
```


```python
pars = [[1.7, 2.],
       [2.3, 1.5] ]

iter_in = 8000
a_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
b_all  = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
for k in range(len(pars)):
    
    a_df = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    b_df  = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    trials = 3
    for j in range(trials):
        HJ_PDE(a_in = pars[k][0],
              b_in = pars[k][1],  iter_in = iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 
                                  0:'par_value_a', 
                                  1:'par_value_b'}, inplace = True)        
        a_df['par_value_a'+str(j)] = params0['par_value_a'].apply(lambda x: float(re.findall('\[.+',x)[0][1:]))
        b_df['par_value_b'+str(j)] = params0['par_value_b'].apply(lambda x: float(re.findall('[^\s].+\]',x)[0][0:-1]))

    
    a_all['mean'+str(k)] = a_df[['par_value_a'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    a_all['std' +str(k)] = a_df[['par_value_a'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

    b_all['mean'+str(k)] = b_df[['par_value_b'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    b_all['std' +str(k)] = b_df[['par_value_b'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

```

    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.094546 s
    
    'compile' took 2.241656 s
    
    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.111447 s
    
    'compile' took 3.577124 s
    
    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.222459 s
    
    'compile' took 4.731310 s
    
    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.123272 s
    
    'compile' took 2.848750 s
    
    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.108702 s
    
    'compile' took 4.241521 s
    
    Warning: 50 points required, but 54 points sampled.
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.116486 s
    
    'compile' took 17.998339 s
    



```python
plt.figure(figsize = (15,6))

plt.subplot(121)
for k in range(len(pars)):
    plt.errorbar(x = a_all['Epoch'], y = a_all['mean'+str(k)], yerr = a_all['std'+str(k)],label = f'Initital Value = {pars[k][0]}')
    plt.scatter( x = a_all['Epoch'], y = a_all['mean'+str(k)])
plt.hlines(1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted A values VS epochs')
plt.legend()

plt.subplot(122)
for k in range(len(pars)):
    plt.errorbar(x = b_all['Epoch'], y = b_all['mean'+str(k)], yerr = b_all['std'+str(k)],label = f'Initital Value = {pars[k][1]}')
    plt.scatter( x = b_all['Epoch'], y = b_all['mean'+str(k)])
plt.hlines(1., xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted B values VS epochs')
plt.legend()


plt.show()
```


    
![png](output_71_0.png)
    


### Schrödinger equation

In this example we will need to find the eigenstates of the Schrödinger equation of the quantum harmonic oscillator 

$$-\frac{\hbar^2}{2m}\frac{d^2 \psi}{dx^2} + \frac{1}{2}mx^2\omega^2 \psi = E\psi. $$

The eigenvalue $E_n = \omega (n + 1/2)$ has the normalized eigenstate

$$
\psi_n(x) = \frac{\omega^{1/4}}{\pi^{1/4} \sqrt{2^n n!}}  H_n\left(\sqrt{\omega} x\right)e^{-\frac{\omega x^2}{2}}.
$$

We will take $\hbar = m=1$. The initial condition is $(\psi(0), \psi'(0)) =(1,0)$ is $n$ is even and $(0,1)$ if $n$ is odd.

* Learn $E$ from data using the function below. 


```python
from numpy.polynomial.hermite import hermval
n = 5
omega = 0.5
E_star = (n + 0.5) * omega
coeff = [0]*n + [1]

def psi_sol(x):
    return (
        1 / (2**n * np.math.factorial(n))**0.5
        * (omega / np.pi)**(1/4)
        * np.exp(-omega * x**2 / 2)
        * hermval(omega**0.5 * x, coeff)
    )

def gen_data(num_pts=100):
    X = np.random.uniform(0, 10, [num_pts, 1])
    
    return X, psi_sol(X)
```


```python
#PINNS Solution

x_min = 0; x_max = 10
geom = dde.geometry.TimeDomain(x_min, x_max)


def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],x_min)

if n % 2 == 1:
    bc_psi_D = dde.icbc.DirichletBC (geom, lambda z: 0, ic_begin, component = 0)
    bc_psi_N = dde.icbc.NeumannBC(geom,lambda z: -1,ic_begin,component=0)
elif n % 2 == 0:
    bc_psi_D = dde.icbc.DirichletBC (geom, lambda z: 1, ic_begin, component = 0)
    bc_psi_N = dde.icbc.NeumannBC(geom,lambda z: 0,ic_begin,component=0)

def SH_ODE(E_in = 5., iter_in = 4000):
    E = tf.Variable(E_in)
    
    points, Psis = gen_data()
    obs_psi = dde.icbc.PointSetBC(points, Psis, component = 0)

    bcs = [bc_psi_D, bc_psi_N, obs_psi]

    def SH_deepxde(z,y):
    
        psi = y[:, 0:1]
        x   = z[:, 0:1]
    
        dpsi_dx = dde.grad.jacobian(psi,z,0,0)
        d2psi_dx2 = dde.grad.jacobian(dpsi_dx,z,0,0)
    
        return (-1/2)*d2psi_dx2  + (1/2)*((omega*x)**2)*psi - E*psi



    data = dde.data.PDE(geom, SH_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 100,
                        num_test = 100
                       )
    
    net = dde.nn.FNN([1] + [60]*4 + [1], 'sin', 'Glorot uniform')
    parameters = dde.callbacks.VariableValue([E], period = 200, filename = 'params.csv')

    model = dde.Model(data, net)
    model.compile('adam', lr = 0.01, metrics = [])
    losshistory, train_state = model.train(iterations = iter_in, 
                                           callbacks = [parameters],
                                          verbose = 0)
    

```


```python
E_ins = [3.5, 2. ]

iter_in = 4000
E_all = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
for k in range(len(E_ins)):
    
    E_df = pd.DataFrame({'Epoch':[200*i for i in range(int(1+iter_in/200))]})
    trials = 3
    for j in range(trials):
        SH_ODE(E_in = E_ins[k], iter_in = iter_in)
        params0 = pd.read_csv('params.csv', header = None)
        params0.reset_index(inplace = True)
        params0.rename(columns = {'index':'Epoch', 
                                  0:'par_value'}, inplace = True)        
        E_df['par_value'+str(j)] = params0['par_value'].apply(lambda x: float(re.findall('\[.+',x)[0][1:-1]))
        
    E_all['mean'+str(k)] = E_df[['par_value'+str(t) for t in range(trials)]].apply(np.mean, axis = 1)
    E_all['std' +str(k)] = E_df[['par_value'+str(t) for t in range(trials)]].apply(np.std, axis = 1)

```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.139108 s
    
    'compile' took 3.526395 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.159645 s
    
    'compile' took 3.769021 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.612040 s
    
    'compile' took 5.781263 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.188865 s
    
    'compile' took 4.738605 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.158359 s
    
    'compile' took 3.623920 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.167204 s
    
    'compile' took 5.245475 s
    



```python
plt.figure(figsize = (5,5))
for k in range(len(E_ins)):
    plt.errorbar(x = E_all['Epoch'], y = E_all['mean'+str(k)], yerr = E_all['std'+str(k)],label = f'Initital Value = {E_ins[k]}')
    plt.scatter(x = E_all['Epoch'], y = E_all['mean'+str(k)])
plt.hlines(E_star, xmin = 0, xmax = iter_in, color = 'green',linewidth = 2., label = 'True Value')
plt.title('Predicted values VS epochs')
plt.legend()
plt.show()
```


    
![png](output_77_0.png)
    


## Parameter Identification with noise

### Simple ODE

$$\frac{dy}{dx} =\cos(\omega x), \quad x\in [-\pi , \pi],$$

with $y(0)=0$.

The exact solution is $y(x)=\frac{1}{\omega}\sin(\omega x)$.

* Use the following function to generate data points and learn the paramater $\omega^*=2$. Try with different levels of noise. Use the parameter `eps` to set the amplitude of the noise.


```python
omega_star = 2
x_max = 2*np.pi

def gen_data(eps=0.1):
    x = np.random.uniform(0, x_max, [10, 1])
    noise = eps*np.random.uniform(-1, 1, [10, 1])
    return x, np.sin(omega_star*x)/omega_star + noise
```


```python
def noisy_params(eps, omega_0 = 1.): # We train the FNN with different values of noise amplitudes. We'll plot the final values for
                       # for Omega in each case. These numbers are close to the expected values...

    omega = tf.Variable(omega_0)
    
    geom = dde.geometry.TimeDomain(-np.pi, np.pi)

    x_begin = 0; y_begin = 0
    def boundary_begin(x,_):  
        return dde.utils.isclose(x[0],x_begin)

    def bc_func_begin(x,y,_): 
        return y - y_begin

    bc1 = dde.icbc.OperatorBC(geom,bc_func_begin,boundary_begin)

    points, ys = gen_data(eps)
    observe = dde.icbc.PointSetBC(points, ys )

    bcs = [bc1, observe]


    def ODE_deepxde(x,y):
        dy_dx = dde.grad.jacobian(y,x)
    
        return dy_dx - tf.cos(omega*x)
                
    data = dde.data.PDE(geom, ODE_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 1, 
                        num_test = 200)

    net = dde.nn.FNN([1] + [40]*4 + [1], 'sin', 'He normal')
    model = dde.Model(data, net)
    
    parameters = dde.callbacks.VariableValue([omega], period=200)
    
    
    model.compile('adam', lr = 0.005, metrics = [])
    losshistory, train_state = model.train(iterations = 1000, 
                                           callbacks=[parameters], 
                                           verbose = 0)

    
    return parameters.value
```


```python
for omega_0 in [1., 1.5, 2., 2.5]:

    omega_vals = [] 
    for e in np.linspace(0,0.5,6):
        val = noisy_params(e, omega_0 = omega_0)
        omega_vals.append(val)
    plt.plot(np.linspace(0,0.5,6), omega_vals, label = 'Omega_0 = {}'.format(omega_0))

plt.hlines(2, 0, 0.6, color = 'r', label='Expected omega')
plt.ylabel('Optimpum omega found by PINNS')
plt.xlabel('Amplitude of noise')
plt.title('Omega^* VS Noise')
plt.legend()
```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.239481 s
    
    'compile' took 6.488103 s
    
    0 [1.00e+00]
    200 [1.41e+00]
    400 [1.72e+00]
    600 [1.87e+00]
    800 [1.95e+00]
    1000 [1.98e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.242165 s
    
    'compile' took 6.499177 s
    
    0 [1.00e+00]
    200 [1.47e+00]
    400 [1.94e+00]
    600 [2.00e+00]
    800 [2.00e+00]
    1000 [2.00e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.460604 s
    
    'compile' took 9.974416 s
    
    0 [1.00e+00]
    200 [1.37e+00]
    400 [2.05e+00]
    600 [2.06e+00]
    800 [2.06e+00]
    1000 [2.06e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.191000 s
    
    'compile' took 63.902661 s
    
    0 [1.00e+00]
    200 [1.01e+00]
    400 [9.93e-01]
    600 [9.87e-01]
    800 [9.95e-01]
    1000 [1.00e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.178341 s
    
    'compile' took 4.005530 s
    
    0 [1.00e+00]
    200 [1.52e+00]
    400 [2.01e+00]
    600 [2.02e+00]
    800 [2.02e+00]
    1000 [2.02e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.193713 s
    
    'compile' took 8.104943 s
    
    0 [1.00e+00]
    200 [1.55e+00]
    400 [2.08e+00]
    600 [2.13e+00]
    800 [2.13e+00]
    1000 [2.13e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.301049 s
    
    'compile' took 11.514144 s
    
    0 [1.50e+00]
    200 [1.88e+00]
    400 [1.99e+00]
    600 [2.00e+00]
    800 [2.00e+00]
    1000 [2.00e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.198036 s
    
    'compile' took 8.368984 s
    
    0 [1.50e+00]
    200 [1.83e+00]
    400 [1.99e+00]
    600 [2.04e+00]
    800 [2.06e+00]
    1000 [2.07e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.194302 s
    
    'compile' took 9.357928 s
    
    0 [1.50e+00]
    200 [1.77e+00]
    400 [1.97e+00]
    600 [2.01e+00]
    800 [2.01e+00]
    1000 [2.01e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 1.220117 s
    
    'compile' took 9.009816 s
    
    0 [1.50e+00]
    200 [1.71e+00]
    400 [1.89e+00]
    600 [1.92e+00]
    800 [1.93e+00]
    1000 [1.93e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.155204 s
    
    'compile' took 6.170181 s
    
    0 [1.50e+00]
    200 [1.71e+00]
    400 [1.86e+00]
    600 [1.89e+00]
    800 [1.89e+00]
    1000 [1.89e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.330566 s
    
    'compile' took 12.454455 s
    
    0 [1.50e+00]
    200 [1.68e+00]
    400 [1.85e+00]
    600 [2.01e+00]
    800 [2.15e+00]
    1000 [2.23e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.299898 s
    
    'compile' took 11.458808 s
    
    0 [2.00e+00]
    200 [2.01e+00]
    400 [2.00e+00]
    600 [2.00e+00]
    800 [2.00e+00]
    1000 [2.00e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.298225 s
    
    'compile' took 13.518935 s
    
    0 [2.00e+00]
    200 [2.02e+00]
    400 [2.02e+00]
    600 [2.02e+00]
    800 [2.02e+00]
    1000 [2.02e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.300238 s
    
    'compile' took 91.157712 s
    
    0 [2.00e+00]
    200 [1.95e+00]
    400 [1.94e+00]
    600 [1.94e+00]
    800 [1.94e+00]
    1000 [1.94e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.243133 s
    
    'compile' took 8.478441 s
    
    0 [2.00e+00]
    200 [2.04e+00]
    400 [2.07e+00]
    600 [2.07e+00]
    800 [2.07e+00]
    1000 [2.06e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.197711 s
    
    'compile' took 8.270985 s
    
    0 [2.00e+00]
    200 [2.06e+00]
    400 [2.06e+00]
    600 [2.06e+00]
    800 [2.06e+00]
    1000 [2.06e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.237777 s
    
    'compile' took 7.626744 s
    
    0 [2.00e+00]
    200 [2.25e+00]
    400 [2.29e+00]
    600 [2.29e+00]
    800 [2.29e+00]
    1000 [2.29e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.235538 s
    
    'compile' took 8.738253 s
    
    0 [2.50e+00]
    200 [2.12e+00]
    400 [2.00e+00]
    600 [2.00e+00]
    800 [2.00e+00]
    1000 [2.00e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.649168 s
    
    'compile' took 15.658017 s
    
    0 [2.50e+00]
    200 [2.29e+00]
    400 [2.13e+00]
    600 [2.10e+00]
    800 [2.09e+00]
    1000 [2.09e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.129809 s
    
    'compile' took 9.278556 s
    
    0 [2.50e+00]
    200 [2.13e+00]
    400 [2.02e+00]
    600 [2.01e+00]
    800 [2.01e+00]
    1000 [2.01e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.219638 s
    
    'compile' took 12.119274 s
    
    0 [2.50e+00]
    200 [2.10e+00]
    400 [1.98e+00]
    600 [1.98e+00]
    800 [1.98e+00]
    1000 [1.98e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 2.009854 s
    
    'compile' took 17.455265 s
    
    0 [2.50e+00]
    200 [2.48e+00]
    400 [2.43e+00]
    600 [2.38e+00]
    800 [2.34e+00]
    1000 [2.32e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.378225 s
    
    'compile' took 17.401820 s
    
    0 [2.50e+00]
    200 [2.26e+00]
    400 [2.18e+00]
    600 [2.17e+00]
    800 [2.17e+00]
    1000 [2.17e+00]





    <matplotlib.legend.Legend at 0x18e0f8710>




    
![png](output_83_2.png)
    


From the graph above for different values of $\omega_0$, the value of $\omega$ found by PINNS diverges from the true value $\omega_0$. 

### Heat equation

$$w_t - \lambda w_{xx}=0,\qquad (x,t)\in (0,1)\times (0,1),$$

with initial condition

$$ w(x,0) = x^2+1,$$

and boundary conditions

$$ w(0,t) = 2\lambda t + 1\qquad \text{and}\qquad w(1,t)= 2\lambda t +2.$$

The exact solution is

$$w(x,t)=x^2 +2\lambda t+1.$$

* Use the following function to generate data points and learn the paramater $\lambda^*=0.5$.

* Try with different `eps`.


```python
lmbda_star = 0.5

def gen_data(eps=0.1):
    z = np.random.uniform(0, 1, [10, 2])
    noise = eps*np.random.uniform(-1, 1, [10, 1])

    return z, z[:,0:1]**2 + 2*lmbda_star*z[:,1:2] + 1 + noise
```


```python
def noisy_params(eps, Lambda_0 = 1.5):
    Lambda = tf.Variable(Lambda_0)

    geom = dde.geometry.Rectangle((0,0), (1, 1))
    x_begin = 0; x_end = 1
    def boundary_bottom(z,on_boundary):  
        return dde.utils.isclose(z[1],x_begin)

    def boundary_top(z,on_boundary):  
        return dde.utils.isclose(z[1],x_end)

    def ic_begin(z,on_boundary):
        return dde.utils.isclose(z[0],0)


    bc_bottom = dde.icbc.DirichletBC (geom, lambda z: 2*lmbda_star*z[:,0:1] + 1, boundary_bottom)
    bc_top    = dde.icbc.DirichletBC (geom, lambda z: 2*lmbda_star*z[:,0:1] + 2, boundary_top)
    bc_ic     = dde.icbc.DirichletBC (geom, lambda z: (z[:,1:2])**2 + 1, ic_begin)

    points, ws = gen_data(eps)
    observe   = dde.icbc.PointSetBC(points, ws)

    bcs = [bc_bottom,bc_top,bc_ic,observe]

    def HEAT_deepxde(z,w):
        dw_dt = dde.grad.jacobian(w,z,0,0)
        dw_dx = dde.grad.jacobian(w,z,0,1)
        d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
        return dw_dt - Lambda * d2w_dx2
    
    
    data = dde.data.PDE(geom, HEAT_deepxde,bcs, 
                        num_domain = 1000,
                        num_boundary = 6, 
                       anchors = points)
    
    net = dde.nn.FNN([2] + [30]*4 + [1], 'tanh', 'Glorot normal')
    parameters = dde.callbacks.VariableValue([Lambda], period=3000)

    model = dde.Model(data, net)
    model.compile('adam', lr = 0.05, metrics = [])
    losshistory, train_state = model.train(iterations = 1000, callbacks=[parameters],verbose = 0)
    
    return parameters.value
```


```python
out = []
for l0 in [0.75, 1., 0.5]:
    
    Lambda_vals = [] 
    for e in np.linspace(0,0.9,3):
        val = noisy_params(e, l0)
        Lambda_vals.append(val)
    out.append(Lambda_vals)
```

    Compiling model...
    Building feed-forward neural network...
    'build' took 1.645048 s
    
    'compile' took 13.081787 s
    
    0 [7.50e-01]
    1000 [5.90e-01]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.371944 s
    
    'compile' took 12.078816 s
    
    0 [7.50e-01]
    1000 [1.15e+00]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.405281 s
    
    'compile' took 10.990316 s
    
    0 [7.50e-01]
    1000 [-8.97e-02]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.473489 s
    
    'compile' took 12.742409 s
    
    0 [1.00e+00]
    1000 [7.04e-01]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.343810 s
    
    'compile' took 64.318096 s
    
    0 [1.00e+00]
    1000 [6.97e-01]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.325426 s
    
    'compile' took 8.174716 s
    
    0 [1.00e+00]
    1000 [2.35e-01]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.211384 s
    
    'compile' took 7.753192 s
    
    0 [5.00e-01]
    1000 [-7.71e-03]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.141026 s
    
    'compile' took 4.190426 s
    
    0 [5.00e-01]
    1000 [8.76e-01]
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.143623 s
    
    'compile' took 6.895957 s
    
    0 [5.00e-01]
    1000 [9.91e-01]



```python
plt.figure(figsize=(5,5))
Lambda_0_vals = [0.75, 1., 0.5]
for i in range(3):
    
    plt.plot(np.linspace(0,0.9,3), out[i], label = 'Lambda_0 = {}'.format(Lambda_0_vals[i]))

plt.hlines(0.5, 0, 0.9, color = 'r',linestyles = '--', label='Expected lambda')
plt.ylabel('Optimpum lambda found by PINNS')
plt.xlabel('Amplitude of noise')
plt.title('Learned lambda VS Noise')
plt.legend()

plt.show()
```


    
![png](output_90_0.png)
    


As the value of the noise amplitude increases, the value of $\lambda$ learned by PINNS diverges from the expected value.

### A system of linear PDEs

Consider the system 
$$
\begin{cases}
v_t - \frac{1}{2} v_{xx} = \alpha v +\beta w,\\
w_t - \frac{1}{2} w_{xx} = \gamma v + \delta w.
\end{cases}
$$

with initial conditions

$$
\begin{array}{l}
v(x,0) = x^2+1,\\
w(x,0) = 0,
\end{array}
$$

and boundary conditions

$$
\begin{array}{l}
v(0,t) = \left(t+1\right)e^{-t}, \\
v(1,t) = \left(t+2\right)e^{-t},\\
w(0,t) = \left(t+1\right)\left(e^{-t}-e^{-2t}\right), \\
w(1,t) = \left(t+2\right)\left(e^{-t}-e^{-2t}\right).
\end{array}
$$

The true parameters are

$$
\alpha^* =  -1, \quad \beta^* = 0, \quad \gamma^* = 1, \quad \delta^* =-2,
$$ 

and the exact solution of the system is

$$
\begin{array}{l}
v(x,t)= \left(x^2 + t + 1\right)e^{- t},\\
w(x,t)= \left(x^2 + t + 1\right)\left(e^{- t}-  e^{-2t}\right).
\end{array}
$$

* Use noisy data to learn $\alpha, \beta, \gamma$ and $ \delta$. Try with different values of `eps`.


```python
x_max = 1
t_max = 1

def v_sol(X, T):
    return (X**2 + T + 1)*np.exp(-T)
def w_sol(X, T):
    return (X**2 + T + 1)*(np.exp(-T) - np.exp(-2*T))

def gen_data(eps=0.05):
    Z = np.random.uniform(0, 1, [10, 2])
    v = v_sol(Z[:,:1], Z[:,1:])
    w = w_sol(Z[:,:1], Z[:,1:])
    noise = eps*np.random.uniform(-1, 1, [10, 2])

    return Z, np.stack([v.flatten(), w.flatten()], 1) + noise
```


```python
def noisy_params(eps):
    alpha = tf.Variable(-0.5)
    beta  = tf.Variable(0.2)
    gamma = tf.Variable(1.2)
    delta = tf.Variable(-2.2)

    geom = dde.geometry.Rectangle((0,0), (1, 1))

    x_begin = 0; x_end = 1
    def boundary_bottom(z,on_boundary):  
        return dde.utils.isclose(z[1],x_begin)

    def boundary_top(z,on_boundary):  
        return dde.utils.isclose(z[1],x_end)

    def ic_begin(z,on_boundary):
        return dde.utils.isclose(z[0],0)


    a = 0.5

    bc_bottom_v = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*tf.exp(-z[:,0:1])], boundary_bottom, component = 0)
    bc_bottom_w = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 1)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_bottom, component = 1)

    bc_top_v    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*tf.exp(-z[:,0:1])],boundary_top, component = 0)
    bc_top_w    = dde.icbc.DirichletBC (geom, lambda z: [(2*a*z[:,0:1] + 2)*(tf.exp(-z[:,0:1])-tf.exp(-2*z[:,0:1]))],boundary_top, component = 1)

    points, Zs = gen_data(eps)
    obs_v = dde.icbc.PointSetBC(points, Zs[:,0:1],component = 0)
    obs_w = dde.icbc.PointSetBC(points, Zs[:,1:2],component = 1)

    bcs = [bc_top_v, bc_top_w, bc_bottom_v, bc_bottom_w, obs_v, obs_w]


    def HEAT2_deepxde(z,y):
    
        v = y[:,0:1]
        w = y[:,1:2]
    
        dw_dt = dde.grad.jacobian(w,z,0,0)
        dw_dx = dde.grad.jacobian(w,z,0,1)
        d2w_dx2 = dde.grad.jacobian(dw_dx,z,0,1)
    
        dv_dt = dde.grad.jacobian(v,z,0,0)
        dv_dx = dde.grad.jacobian(v,z,0,1)
        d2v_dx2 = dde.grad.jacobian(dv_dx,z,0,1)
    
        return [
            dv_dt - a * d2v_dx2 - alpha*v - beta*w,
            dw_dt - a * d2w_dx2 - gamma*v - delta*w
        ]

    def output_transform(z, q):
        v = q[:, 0:1]
        w = q[:, 1:2]
        t = z[:, 0:1]
        x = z[:, 1:2]
        return tf.concat([v * tf.tanh(t) + x**2+1, w * tf.tanh(t)], axis=1)


    data = dde.data.PDE(geom, HEAT2_deepxde,bcs, 
                            num_domain = 1000,
                            num_boundary = 6,
                            num_test=100,
                       anchors = points)
    
    net = dde.nn.FNN([2] + [60]*4 + [2], 'tanh', 'He uniform')
    net.apply_output_transform(output_transform)
    parameters = dde.callbacks.VariableValue([alpha,beta,gamma,delta], period = 200)


    model = dde.Model(data, net)
    model.compile('adam', lr = 0.005, metrics = [])
    losshistory, train_state = model.train(iterations = 1000, callbacks = [parameters])
    
    return parameters.value
```


```python
alpha_vals = []
beta_vals = []
gamma_vals = []
delta_vals = []
for e in np.linspace(0,0.5,6):
    val = noisy_params(e)
    alpha_vals.append(val[0])
    beta_vals.append(val[1])
    gamma_vals.append(val[2])
    delta_vals.append(val[3])
```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.103256 s
    
    'compile' took 2.676728 s
    


    2024-09-30 19:04:10.286009: I tensorflow/compiler/mlir/mlir_graph_optimization_pass.cc:375] MLIR V1 optimization pass is not enabled


    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [7.78e-01, 4.35e+00, 6.02e-01, 3.67e-01, 1.02e-01, 4.37e-02, 2.67e-01, 1.52e-01]    [7.34e-01, 4.29e+00, 6.02e-01, 3.67e-01, 1.02e-01, 4.37e-02, 2.67e-01, 1.52e-01]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-7.43e-01, 1.12e-01, 1.18e+00, -2.16e+00]
    400 [-7.20e-01, 2.07e-01, 1.17e+00, -2.17e+00]
    600 [-6.81e-01, 3.20e-01, 1.16e+00, -2.18e+00]
    800 [-6.35e-01, 4.35e-01, 1.14e+00, -2.19e+00]
    1000      [1.05e-02, 3.44e-04, 8.31e-03, 6.41e-05, 9.01e-03, 9.55e-04, 7.22e-02, 1.43e-02]    [8.34e-03, 2.52e-04, 8.31e-03, 6.41e-05, 9.01e-03, 9.55e-04, 7.22e-02, 1.43e-02]    []  
    1000 [-6.01e-01, 5.37e-01, 1.12e+00, -2.20e+00]
    
    Best model at step 1000:
      train loss: 1.16e-01
      test loss: 1.13e-01
      test metric: []
    
    'train' took 36.231600 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.108315 s
    
    'compile' took 3.168267 s
    
    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [8.75e+00, 3.36e+00, 2.93e-01, 9.02e-01, 3.38e-01, 3.50e-02, 1.78e+00, 1.76e-01]    [9.50e+00, 3.18e+00, 2.93e-01, 9.02e-01, 3.38e-01, 3.50e-02, 1.78e+00, 1.76e-01]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-7.51e-01, 3.47e-02, 1.12e+00, -2.21e+00]
    400 [-7.41e-01, 7.66e-02, 1.08e+00, -2.22e+00]
    600 [-7.21e-01, 1.17e-01, 1.06e+00, -2.23e+00]
    800 [-7.01e-01, 1.67e-01, 1.04e+00, -2.24e+00]
    1000      [5.90e-04, 3.59e-04, 4.63e-05, 2.07e-06, 3.59e-03, 2.66e-03, 3.98e-02, 3.07e-02]    [4.25e-04, 1.71e-04, 4.63e-05, 2.07e-06, 3.59e-03, 2.66e-03, 3.98e-02, 3.07e-02]    []  
    1000 [-6.83e-01, 2.17e-01, 1.03e+00, -2.25e+00]
    
    Best model at step 1000:
      train loss: 7.77e-02
      test loss: 7.74e-02
      test metric: []
    
    'train' took 28.726745 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.137802 s
    
    'compile' took 3.329800 s
    
    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [5.44e-01, 4.59e+00, 2.55e-01, 8.62e-01, 4.94e-02, 8.71e-02, 9.24e-02, 4.30e-01]    [4.92e-01, 4.64e+00, 2.55e-01, 8.62e-01, 4.94e-02, 8.71e-02, 9.24e-02, 4.30e-01]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-7.49e-01, 3.37e-02, 1.18e+00, -2.16e+00]
    400 [-7.58e-01, 6.88e-02, 1.17e+00, -2.16e+00]
    600 [-7.59e-01, 1.20e-01, 1.15e+00, -2.16e+00]
    800 [-7.61e-01, 1.78e-01, 1.13e+00, -2.17e+00]
    1000      [7.23e-04, 1.33e-04, 8.16e-04, 1.10e-04, 1.27e-03, 1.72e-05, 3.19e-02, 1.05e-02]    [5.09e-04, 5.60e-05, 8.16e-04, 1.10e-04, 1.27e-03, 1.72e-05, 3.19e-02, 1.05e-02]    []  
    1000 [-7.64e-01, 2.41e-01, 1.12e+00, -2.17e+00]
    
    Best model at step 1000:
      train loss: 4.55e-02
      test loss: 4.52e-02
      test metric: []
    
    'train' took 29.401684 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.115648 s
    
    'compile' took 2.784001 s
    
    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [1.02e+00, 8.32e-01, 4.46e-01, 4.10e-03, 1.40e-02, 4.27e-02, 3.25e-01, 6.32e-02]    [6.45e-01, 8.15e-01, 4.46e-01, 4.10e-03, 1.40e-02, 4.27e-02, 3.25e-01, 6.32e-02]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-7.04e-01, 1.10e-01, 1.18e+00, -2.17e+00]
    400 [-6.88e-01, 2.40e-01, 1.19e+00, -2.17e+00]
    600 [-6.84e-01, 3.68e-01, 1.20e+00, -2.17e+00]
    800 [-7.00e-01, 4.81e-01, 1.22e+00, -2.16e+00]
    1000      [3.45e-03, 4.84e-04, 2.54e-04, 9.23e-04, 7.94e-03, 3.47e-03, 1.05e-01, 3.66e-02]    [1.10e-03, 2.86e-04, 2.54e-04, 9.23e-04, 7.94e-03, 3.47e-03, 1.05e-01, 3.66e-02]    []  
    1000 [-7.36e-01, 5.87e-01, 1.23e+00, -2.15e+00]
    
    Best model at step 1000:
      train loss: 1.58e-01
      test loss: 1.56e-01
      test metric: []
    
    'train' took 30.571830 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.102648 s
    
    'compile' took 2.899069 s
    
    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [5.10e-01, 3.02e-01, 7.48e-01, 2.07e-02, 2.43e-01, 2.93e-02, 2.29e-01, 9.55e-02]    [4.15e-01, 2.29e-01, 7.48e-01, 2.07e-02, 2.43e-01, 2.93e-02, 2.29e-01, 9.55e-02]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-8.01e-01, 9.22e-02, 1.17e+00, -2.18e+00]
    400 [-8.24e-01, 1.92e-01, 1.17e+00, -2.18e+00]
    600 [-8.44e-01, 3.32e-01, 1.17e+00, -2.20e+00]
    800 [-8.66e-01, 4.95e-01, 1.17e+00, -2.21e+00]
    1000      [8.31e-03, 9.11e-04, 1.41e-03, 4.57e-05, 9.63e-03, 6.53e-04, 2.26e-01, 8.60e-02]    [5.56e-03, 5.04e-04, 1.41e-03, 4.57e-05, 9.63e-03, 6.53e-04, 2.26e-01, 8.60e-02]    []  
    1000 [-8.94e-01, 6.70e-01, 1.18e+00, -2.22e+00]
    
    Best model at step 1000:
      train loss: 3.33e-01
      test loss: 3.30e-01
      test metric: []
    
    'train' took 31.743840 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.074188 s
    
    'compile' took 3.011043 s
    
    Training model...
    
    Step      Train loss                                                                          Test loss                                                                           Test metric
    0         [8.13e-01, 2.57e+00, 2.12e+00, 1.87e-01, 5.20e-02, 1.07e-01, 1.32e+00, 2.00e-01]    [8.48e-01, 2.50e+00, 2.12e+00, 1.87e-01, 5.20e-02, 1.07e-01, 1.32e+00, 2.00e-01]    []  
    0 [-5.00e-01, 2.00e-01, 1.20e+00, -2.20e+00]
    200 [-6.92e-01, 1.13e-01, 1.17e+00, -2.17e+00]
    400 [-6.91e-01, 2.08e-01, 1.15e+00, -2.16e+00]
    600 [-6.87e-01, 3.28e-01, 1.14e+00, -2.16e+00]
    800 [-6.89e-01, 4.56e-01, 1.12e+00, -2.15e+00]
    1000      [2.55e-03, 5.35e-04, 6.16e-04, 1.26e-04, 6.62e-03, 6.82e-04, 1.87e-01, 5.73e-02]    [1.71e-03, 3.85e-04, 6.16e-04, 1.26e-04, 6.62e-03, 6.82e-04, 1.87e-01, 5.73e-02]    []  
    1000 [-6.92e-01, 5.91e-01, 1.12e+00, -2.15e+00]
    
    Best model at step 1000:
      train loss: 2.55e-01
      test loss: 2.54e-01
      test metric: []
    
    'train' took 44.963234 s
    



```python
plt.figure(figsize=(10,8))

plt.plot(np.linspace(0,0.5,6), alpha_vals,'b', label = 'alpha')
plt.hlines(-1,0,0.5, color = 'b', linestyles = '--', label = 'Expected alpha')
plt.plot(np.linspace(0,0.5,6), beta_vals, 'g', label = 'beta')
plt.hlines(0,0,0.5, color = 'g', linestyles = '--', label = 'Expected beta')
plt.plot(np.linspace(0,0.5,6), gamma_vals,'r',  label = 'gamma')
plt.hlines(1,0,0.5, color = 'r', linestyles = '--', label = 'Expected gamma')
plt.plot(np.linspace(0,0.5,6), delta_vals,'y', label = 'delta')
plt.hlines(-2,0,0.5, color = 'y', linestyles = '--', label = 'Expected delta')

plt.xlabel('Optimpum paramter values found by PINNS')
plt.ylabel('Amplitude of noise')
plt.title('Parameters^* VS Noise')
plt.legend()
```




    <matplotlib.legend.Legend at 0x16b98cd90>




    
![png](output_97_1.png)
    


The value of the paramters learned by PINNS seems to be stable relative to the noise amplitude.

### Schrödinger equation

In this example you will need to find the eigenstates of the Schrödinger equation of the quantum harmonic oscillator 

$$-\frac{\hbar^2}{2m}\frac{d^2 \psi}{dx^2} + \frac{1}{2}mx^2\omega^2 \psi = E\psi. $$

The eigenvalue $E_n = \omega (n + 1/2)$ has the normalized eigenstate

$$
\psi_n(x) = \frac{\omega^{1/4}}{\pi^{1/4} \sqrt{2^n n!}}  H_n\left(\sqrt{\omega} x\right)e^{-\frac{\omega x^2}{2}}.
$$

We will take $\hbar = m=1$. The initial condition is $(\psi(0), \psi'(0)) =(1,0)$ is $n$ is even and $(0,1)$ if $n$ is odd.

* Learn $E$ from data. Try with different values of `num_pts` and `eps`.


```python
from numpy.polynomial.hermite import hermval
```


```python
n = 5
omega = 0.5
E_star = (n + 0.5) * omega
coeff = [0]*n + [1]

def psi_sol(x):
    return (
        1 / (2**n * np.math.factorial(n))**0.5
        * (omega / np.pi)**(1/4)
        * np.exp(-omega * x**2 / 2)
        * hermval(omega**0.5 * x, coeff)
    )

def gen_data(num_pts=100, eps=0.1):
    X = np.random.uniform(0, 10, [num_pts, 1])
    noise = eps*np.random.uniform(-1, 1, [num_pts, 1])
    return X, psi_sol(X) + noise
```


```python
#PINNS Solution

x_min = 0; x_max = 10
geom = dde.geometry.TimeDomain(x_min, x_max)


def ic_begin(z,on_boundary):
    return dde.utils.isclose(z[0],x_min)

if n % 2 == 1:
    bc_psi_D = dde.icbc.DirichletBC (geom, lambda z: 0, ic_begin, component = 0)
    bc_psi_N = dde.icbc.NeumannBC(geom,lambda z: -1,ic_begin,component=0)
elif n % 2 == 0:
    bc_psi_D = dde.icbc.DirichletBC (geom, lambda z: 1, ic_begin, component = 0)
    bc_psi_N = dde.icbc.NeumannBC(geom,lambda z: 0,ic_begin,component=0)

def SH_ODE(eps=0.1, num_pts=100 , E_in = 5.):
    E = tf.Variable(E_in)
    
    points, Psis = gen_data(num_pts, eps)
    obs_psi = dde.icbc.PointSetBC(points, Psis, component = 0)

    bcs = [bc_psi_D, bc_psi_N, obs_psi]

    def SH_deepxde(z,y):
    
        psi = y[:, 0:1]
        x   = z[:, 0:1]
    
        dpsi_dx = dde.grad.jacobian(psi,z,0,0)
        d2psi_dx2 = dde.grad.jacobian(dpsi_dx,z,0,0)
    
        return (-1/2)*d2psi_dx2  + (1/2)*((omega*x)**2)*psi - E*psi



    data = dde.data.PDE(geom, SH_deepxde,bcs, 
                        num_domain = 1500,
                        num_boundary = 2,
                        num_test = 100,
                        anchors = points
                       )
    
    net = dde.nn.FNN([1] + [60]*4 + [1], 'tanh', 'Glorot uniform')
    parameters = dde.callbacks.VariableValue([E], period = 200)

    model = dde.Model(data, net)
    model.compile('adam', lr = 0.01, metrics = [])
    losshistory, train_state = model.train(iterations = 2000, callbacks = [parameters])
    
    return parameters.value
```


```python
out = []
nums = [100,150,200]
nois = [0.1, 0.3, 0.5, 0.7]
for i in range(3):
    Es = []
    for eps in nois:
        Es.append(SH_ODE(eps=eps, num_pts=nums[i] , E_in = 2.5)[0])
    out.append(Es)

```

    Compiling model...
    Building feed-forward neural network...
    'build' took 0.247248 s
    
    'compile' took 3.534623 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [5.41e-01, 1.00e+00, 4.06e-05, 5.81e-02]    [5.22e-01, 1.00e+00, 4.06e-05, 5.81e-02]    []  
    0 [2.50e+00]
    200 [2.57e+00]
    400 [2.53e+00]
    600 [2.48e+00]
    800 [2.43e+00]
    1000      [3.22e-02, 4.94e-03, 8.61e-05, 3.82e-02]    [3.21e-02, 4.94e-03, 8.61e-05, 3.82e-02]    []  
    1000 [2.36e+00]
    1200 [2.28e+00]
    1400 [2.22e+00]
    1600 [2.16e+00]
    1800 [2.13e+00]
    2000      [2.55e-02, 3.54e-03, 3.69e-05, 3.50e-02]    [2.58e-02, 3.54e-03, 3.69e-05, 3.50e-02]    []  
    2000 [2.09e+00]
    
    Best model at step 2000:
      train loss: 6.41e-02
      test loss: 6.43e-02
      test metric: []
    
    'train' took 82.109956 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.198978 s
    
    'compile' took 5.007013 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [2.49e-01, 1.00e+00, 6.72e-03, 1.04e-01]    [2.43e-01, 1.00e+00, 6.72e-03, 1.04e-01]    []  
    0 [2.50e+00]
    200 [2.57e+00]
    400 [2.52e+00]
    600 [2.46e+00]
    800 [2.38e+00]
    1000      [2.71e-02, 5.29e-03, 2.24e-05, 7.07e-02]    [2.69e-02, 5.29e-03, 2.24e-05, 7.07e-02]    []  
    1000 [2.30e+00]
    1200 [2.23e+00]
    1400 [2.18e+00]
    1600 [2.14e+00]
    1800 [2.11e+00]
    2000      [3.54e-02, 7.44e-03, 2.48e-03, 6.67e-02]    [3.56e-02, 7.44e-03, 2.48e-03, 6.67e-02]    []  
    2000 [2.09e+00]
    
    Best model at step 1000:
      train loss: 1.03e-01
      test loss: 1.03e-01
      test metric: []
    
    'train' took 75.847336 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.080769 s
    
    'compile' took 2.742356 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.65e-01, 1.00e+00, 2.82e-02, 1.88e-01]    [1.66e-01, 1.00e+00, 2.82e-02, 1.88e-01]    []  
    0 [2.50e+00]
    200 [2.57e+00]
    400 [2.54e+00]
    600 [2.51e+00]
    800 [2.47e+00]
    1000      [2.84e-02, 9.68e-03, 8.68e-07, 1.41e-01]    [2.86e-02, 9.68e-03, 8.68e-07, 1.41e-01]    []  
    1000 [2.41e+00]
    1200 [2.34e+00]
    1400 [2.28e+00]
    1600 [2.23e+00]
    1800 [2.19e+00]
    2000      [2.07e-02, 8.12e-03, 1.48e-05, 1.38e-01]    [2.11e-02, 8.12e-03, 1.48e-05, 1.38e-01]    []  
    2000 [2.16e+00]
    
    Best model at step 2000:
      train loss: 1.67e-01
      test loss: 1.68e-01
      test metric: []
    
    'train' took 73.965234 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.130448 s
    
    'compile' took 22.227049 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [6.45e+00, 1.00e+00, 1.27e-01, 5.87e-01]    [6.41e+00, 1.00e+00, 1.27e-01, 5.87e-01]    []  
    0 [2.50e+00]
    200 [2.56e+00]
    400 [2.51e+00]
    600 [2.46e+00]
    800 [2.40e+00]
    1000      [3.73e-02, 1.05e-02, 9.80e-06, 2.08e-01]    [3.78e-02, 1.05e-02, 9.80e-06, 2.08e-01]    []  
    1000 [2.34e+00]
    1200 [2.28e+00]
    1400 [2.22e+00]
    1600 [2.16e+00]
    1800 [2.12e+00]
    2000      [7.55e-02, 6.00e-03, 8.55e-03, 2.09e-01]    [7.59e-02, 6.00e-03, 8.55e-03, 2.09e-01]    []  
    2000 [2.08e+00]
    
    Best model at step 1000:
      train loss: 2.56e-01
      test loss: 2.56e-01
      test metric: []
    
    'train' took 73.387040 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.157818 s
    
    'compile' took 3.776344 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [5.60e+00, 1.00e+00, 4.78e-02, 2.45e-01]    [5.40e+00, 1.00e+00, 4.78e-02, 2.45e-01]    []  
    0 [2.50e+00]
    200 [2.59e+00]
    400 [2.55e+00]
    600 [2.51e+00]
    800 [2.47e+00]
    1000      [2.52e-01, 1.97e-02, 9.43e-03, 5.51e-02]    [2.47e-01, 1.97e-02, 9.43e-03, 5.51e-02]    []  
    1000 [2.41e+00]
    1200 [2.35e+00]
    1400 [2.28e+00]
    1600 [2.23e+00]
    1800 [2.17e+00]
    2000      [2.87e-02, 7.12e-03, 2.05e-06, 4.68e-02]    [2.95e-02, 7.12e-03, 2.05e-06, 4.68e-02]    []  
    2000 [2.12e+00]
    
    Best model at step 2000:
      train loss: 8.26e-02
      test loss: 8.35e-02
      test metric: []
    
    'train' took 79.455555 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.191063 s
    
    'compile' took 3.979969 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [3.63e+00, 1.00e+00, 1.49e-02, 1.57e-01]    [3.59e+00, 1.00e+00, 1.49e-02, 1.57e-01]    []  
    0 [2.50e+00]
    200 [2.56e+00]
    400 [2.52e+00]
    600 [2.47e+00]
    800 [2.39e+00]
    1000      [3.32e-02, 5.82e-03, 6.62e-05, 6.43e-02]    [3.33e-02, 5.82e-03, 6.62e-05, 6.43e-02]    []  
    1000 [2.32e+00]
    1200 [2.25e+00]
    1400 [2.19e+00]
    1600 [2.14e+00]
    1800 [2.10e+00]
    2000      [3.14e-02, 4.50e-03, 3.32e-05, 6.07e-02]    [3.16e-02, 4.50e-03, 3.32e-05, 6.07e-02]    []  
    2000 [2.07e+00]
    
    Best model at step 2000:
      train loss: 9.66e-02
      test loss: 9.69e-02
      test metric: []
    
    'train' took 78.825015 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.165888 s
    
    'compile' took 4.174980 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [7.61e-01, 1.00e+00, 7.44e-05, 1.62e-01]    [7.24e-01, 1.00e+00, 7.44e-05, 1.62e-01]    []  
    0 [2.50e+00]
    200 [2.57e+00]
    400 [2.53e+00]
    600 [2.49e+00]
    800 [2.45e+00]
    1000      [4.20e-02, 6.88e-03, 2.56e-05, 1.30e-01]    [4.16e-02, 6.88e-03, 2.56e-05, 1.30e-01]    []  
    1000 [2.41e+00]
    1200 [2.35e+00]
    1400 [2.29e+00]
    1600 [2.25e+00]
    1800 [2.20e+00]
    2000      [2.26e-02, 4.23e-03, 2.44e-05, 1.30e-01]    [2.29e-02, 4.23e-03, 2.44e-05, 1.30e-01]    []  
    2000 [2.17e+00]
    
    Best model at step 2000:
      train loss: 1.57e-01
      test loss: 1.57e-01
      test metric: []
    
    'train' took 80.718618 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.177144 s
    
    'compile' took 3.958345 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [4.39e-01, 1.00e+00, 1.13e-04, 1.58e-01]    [4.28e-01, 1.00e+00, 1.13e-04, 1.58e-01]    []  
    0 [2.50e+00]
    200 [2.58e+00]
    400 [2.55e+00]
    600 [2.51e+00]
    800 [2.47e+00]
    1000      [4.05e-02, 7.14e-03, 3.24e-06, 1.87e-01]    [4.09e-02, 7.14e-03, 3.24e-06, 1.87e-01]    []  
    1000 [2.42e+00]
    1200 [2.37e+00]
    1400 [2.30e+00]
    1600 [2.24e+00]
    1800 [2.18e+00]
    2000      [3.38e-02, 5.99e-03, 1.07e-04, 1.84e-01]    [3.43e-02, 5.99e-03, 1.07e-04, 1.84e-01]    []  
    2000 [2.13e+00]
    
    Best model at step 2000:
      train loss: 2.24e-01
      test loss: 2.24e-01
      test metric: []
    
    'train' took 87.258606 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.128901 s
    
    'compile' took 4.243225 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.56e+00, 1.00e+00, 2.22e-02, 1.70e-01]    [1.57e+00, 1.00e+00, 2.22e-02, 1.70e-01]    []  
    0 [2.50e+00]
    200 [2.57e+00]
    400 [2.53e+00]
    600 [2.50e+00]
    800 [2.45e+00]
    1000      [3.81e-02, 9.50e-03, 1.70e-05, 5.61e-02]    [3.76e-02, 9.50e-03, 1.70e-05, 5.61e-02]    []  
    1000 [2.40e+00]
    1200 [2.33e+00]
    1400 [2.26e+00]
    1600 [2.20e+00]
    1800 [2.15e+00]
    2000      [2.82e-02, 7.50e-03, 2.11e-06, 5.20e-02]    [2.82e-02, 7.50e-03, 2.11e-06, 5.20e-02]    []  
    2000 [2.11e+00]
    
    Best model at step 2000:
      train loss: 8.77e-02
      test loss: 8.77e-02
      test metric: []
    
    'train' took 86.623541 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.133922 s
    
    'compile' took 5.843601 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.34e+00, 1.00e+00, 6.56e-02, 2.67e-01]    [1.31e+00, 1.00e+00, 6.56e-02, 2.67e-01]    []  
    0 [2.50e+00]
    200 [2.58e+00]
    400 [2.55e+00]
    600 [2.51e+00]
    800 [2.47e+00]
    1000      [3.38e-02, 6.49e-03, 4.85e-05, 6.97e-02]    [3.40e-02, 6.49e-03, 4.85e-05, 6.97e-02]    []  
    1000 [2.42e+00]
    1200 [2.36e+00]
    1400 [2.31e+00]
    1600 [2.25e+00]
    1800 [2.20e+00]
    2000      [3.25e-02, 6.84e-03, 8.66e-04, 6.41e-02]    [3.27e-02, 6.84e-03, 8.66e-04, 6.41e-02]    []  


    2000 [2.16e+00]
    
    Best model at step 2000:
      train loss: 1.04e-01
      test loss: 1.05e-01
      test metric: []
    
    'train' took 105.054256 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.389193 s
    
    'compile' took 7.199164 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [3.94e+00, 1.00e+00, 7.04e-02, 3.77e-01]    [3.90e+00, 1.00e+00, 7.04e-02, 3.77e-01]    []  
    0 [2.50e+00]
    200 [2.56e+00]
    400 [2.51e+00]
    600 [2.45e+00]
    800 [2.38e+00]
    1000      [3.62e-02, 6.76e-03, 4.07e-05, 1.19e-01]    [3.56e-02, 6.76e-03, 4.07e-05, 1.19e-01]    []  
    1000 [2.29e+00]
    1200 [2.20e+00]
    1400 [2.12e+00]
    1600 [2.06e+00]
    1800 [2.00e+00]
    2000      [3.46e-02, 5.02e-03, 5.53e-06, 1.13e-01]    [3.42e-02, 5.02e-03, 5.53e-06, 1.13e-01]    []  
    2000 [1.95e+00]
    
    Best model at step 2000:
      train loss: 1.52e-01
      test loss: 1.52e-01
      test metric: []
    
    'train' took 96.807777 s
    
    Compiling model...
    Building feed-forward neural network...
    'build' took 0.328561 s
    
    'compile' took 6.782202 s
    
    Training model...
    
    Step      Train loss                                  Test loss                                   Test metric
    0         [1.79e+01, 1.00e+00, 3.67e-01, 1.18e+00]    [1.73e+01, 1.00e+00, 3.67e-01, 1.18e+00]    []  
    0 [2.50e+00]
    200 [2.58e+00]
    400 [2.51e+00]
    600 [2.45e+00]
    800 [2.36e+00]
    1000      [3.00e-02, 4.72e-03, 4.95e-05, 2.10e-01]    [3.03e-02, 4.72e-03, 4.95e-05, 2.10e-01]    []  
    1000 [2.26e+00]
    1200 [2.19e+00]
    1400 [2.13e+00]
    1600 [2.08e+00]
    1800 [2.05e+00]
    2000      [2.93e-02, 3.74e-03, 3.06e-05, 2.07e-01]    [2.97e-02, 3.74e-03, 3.06e-05, 2.07e-01]    []  
    2000 [2.03e+00]
    
    Best model at step 2000:
      train loss: 2.40e-01
      test loss: 2.40e-01
      test metric: []
    
    'train' took 95.952316 s
    


In the follwoing we plot the results for $n=2$ and $n=5$. Number of observations are [100,150,200], and value for noise amplitudes are [0.1, 0.3, 0.5, 0.7]

For $n=5$ the values of E learned by the NN are less sensitive to noise amplitudes, but hteir value is very different with the expected value of $E^*$.


```python
plt.figure(figsize=(10,10))
nums = [100,150,200]
for i in range(3):
    
    plt.plot(nois, out[i], label = 'num_points = {}'.format(nums[i]))

plt.hlines(E_star, 0, 0.7, color = 'r',linestyles = '--', label='Expected Energy EigenValue')
plt.ylabel('Energy')
plt.xlabel('Amplitude of noise')
plt.title('Learned Energy (for n = {}) VS Noise'.format(2))
plt.legend()

plt.show()
```


    
![png](output_107_0.png)
    



```python
plt.figure(figsize=(10,10))
nums = [100,150,200]
for i in range(3):
    
    plt.plot(nois, out[i], label = 'num_points = {}'.format(nums[i]))

plt.hlines(E_star, 0, 0.7, color = 'r',linestyles = '--', label='Expected Energy EigenValue')
plt.ylabel('Energy')
plt.xlabel('Amplitude of noise')
plt.title('Learned Energy (for n = {}) VS Noise'.format(5))
plt.legend()

plt.show()
```


    
![png](output_108_0.png)
    



```python

```
